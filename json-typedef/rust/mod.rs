// Code generated by jtd-codegen for Rust v0.2.1

use chrono::{DateTime, FixedOffset};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;

/// Describes game rules compatible with the Ironsworn tabletop role-playing
/// game by Shawn Tomkin.
#[derive(Serialize, Deserialize)]
#[serde(tag = "package_type")]
pub enum RulesPackage {
    #[serde(rename = "expansion")]
    Expansion(RulesPackageExpansion),

    #[serde(rename = "ruleset")]
    Ruleset(RulesPackageRuleset),
}

/// A Datasworn package that relies on an external package to provide its
/// ruleset.
#[derive(Serialize, Deserialize)]
pub struct RulesPackageExpansion {
    #[serde(rename = "_id")]
    pub id: ExpansionId,

    /// The version of the Datasworn format used by this data.
    #[serde(rename = "datasworn_version")]
    pub dataswornVersion: SemanticVersion,

    #[serde(rename = "ruleset")]
    pub ruleset: RulesetId,

    /// A dictionary object containing asset collections, which contain assets.
    #[serde(rename = "assets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assets: Option<Box<HashMap<String, AssetCollection>>>,

    /// A dictionary object containing atlas collections, which contain atlas
    /// entries.
    #[serde(rename = "atlas")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub atlas: Option<Box<HashMap<String, Atlas>>>,

    /// Lists authors credited by the source material.
    #[serde(rename = "authors")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authors: Option<Box<Vec<AuthorInfo>>>,

    /// The date of the source documents's last update, formatted YYYY-MM-DD.
    /// Required because it's used to determine whether the data needs updating.
    #[serde(rename = "date")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub date: Option<Box<DateTime<FixedOffset>>>,

    /// A dictionary object of delve sites, like the premade delve sites
    /// presented in Ironsworn: Delve
    #[serde(rename = "delve_sites")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delveSites: Option<Box<HashMap<String, DelveSite>>>,

    #[serde(rename = "license")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub license: Option<Box<License>>,

    /// A dictionary object containing move categories, which contain moves.
    #[serde(rename = "moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moves: Option<Box<HashMap<String, MoveCategory>>>,

    /// A dictionary object containing NPC collections, which contain NPCs.
    #[serde(rename = "npcs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub npcs: Option<Box<HashMap<String, NpcCollection>>>,

    /// A dictionary object containing oracle collections, which may contain
    /// oracle tables and/or oracle collections.
    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<HashMap<String, OracleTablesCollection>>>,

    /// A dictionary object containing rarities, like those presented in
    /// Ironsworn: Delve.
    #[serde(rename = "rarities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rarities: Option<Box<HashMap<String, Rarity>>>,

    #[serde(rename = "rules")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rules: Option<Box<RulesExpansion>>,

    /// A dictionary object containing delve site domains.
    #[serde(rename = "site_domains")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteDomains: Option<Box<HashMap<String, DelveSiteDomain>>>,

    /// A dictionary object containing delve site themes.
    #[serde(rename = "site_themes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteThemes: Option<Box<HashMap<String, DelveSiteTheme>>>,

    /// The title of the source document.
    #[serde(rename = "title")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub title: Option<Box<String>>,

    /// A dictionary object of truth categories.
    #[serde(rename = "truths")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub truths: Option<Box<HashMap<String, Truth>>>,

    /// A URL where the source document is available.
    #[serde(rename = "url")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<Box<WebUrl>>,
}

/// A standalone Datasworn package that describes its own ruleset.
#[derive(Serialize, Deserialize)]
pub struct RulesPackageRuleset {
    #[serde(rename = "_id")]
    pub id: RulesetId,

    /// A dictionary object containing asset collections, which contain assets.
    #[serde(rename = "assets")]
    pub assets: HashMap<String, AssetCollection>,

    /// Lists authors credited by the source material.
    #[serde(rename = "authors")]
    pub authors: Vec<AuthorInfo>,

    /// The version of the Datasworn format used by this data.
    #[serde(rename = "datasworn_version")]
    pub dataswornVersion: SemanticVersion,

    /// The date of the source documents's last update, formatted YYYY-MM-DD.
    /// Required because it's used to determine whether the data needs updating.
    #[serde(rename = "date")]
    pub date: DateTime<FixedOffset>,

    #[serde(rename = "license")]
    pub license: License,

    /// A dictionary object containing move categories, which contain moves.
    #[serde(rename = "moves")]
    pub moves: HashMap<String, MoveCategory>,

    /// A dictionary object containing oracle collections, which may contain
    /// oracle tables and/or oracle collections.
    #[serde(rename = "oracles")]
    pub oracles: HashMap<String, OracleTablesCollection>,

    #[serde(rename = "rules")]
    pub rules: Rules,

    /// The title of the source document.
    #[serde(rename = "title")]
    pub title: String,

    /// A URL where the source document is available.
    #[serde(rename = "url")]
    pub url: WebUrl,

    /// A dictionary object containing atlas collections, which contain atlas
    /// entries.
    #[serde(rename = "atlas")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub atlas: Option<Box<HashMap<String, Atlas>>>,

    /// A dictionary object of delve sites, like the premade delve sites
    /// presented in Ironsworn: Delve
    #[serde(rename = "delve_sites")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delveSites: Option<Box<HashMap<String, DelveSite>>>,

    /// A dictionary object containing NPC collections, which contain NPCs.
    #[serde(rename = "npcs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub npcs: Option<Box<HashMap<String, NpcCollection>>>,

    /// A dictionary object containing rarities, like those presented in
    /// Ironsworn: Delve.
    #[serde(rename = "rarities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rarities: Option<Box<HashMap<String, Rarity>>>,

    /// A dictionary object containing delve site domains.
    #[serde(rename = "site_domains")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteDomains: Option<Box<HashMap<String, DelveSiteDomain>>>,

    /// A dictionary object containing delve site themes.
    #[serde(rename = "site_themes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteThemes: Option<Box<HashMap<String, DelveSiteTheme>>>,

    /// A dictionary object of truth categories.
    #[serde(rename = "truths")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub truths: Option<Box<HashMap<String, Truth>>>,
}

#[derive(Serialize, Deserialize)]
pub enum ActionRollMethod {
    /// Use _every_ roll option at once.
    #[serde(rename = "all")]
    All,

    /// Use the roll option with the best/highest value.
    #[serde(rename = "highest")]
    Highest,

    /// Use the roll option with the worst/lowest value.
    #[serde(rename = "lowest")]
    Lowest,

    /// An automatic miss.
    #[serde(rename = "miss")]
    Miss,

    /// The player chooses which roll option to use.
    #[serde(rename = "player_choice")]
    PlayerChoice,

    /// An automatic strong hit.
    #[serde(rename = "strong_hit")]
    StrongHit,

    /// An automatic weak hit.
    #[serde(rename = "weak_hit")]
    WeakHit,
}

#[derive(Serialize, Deserialize)]
pub struct Asset {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: AssetId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "abilities")]
    pub abilities: Vec<AssetAbility>,

    /// A localized category label for this asset. This is the surtitle above
    /// the asset's name on the card.
    #[serde(rename = "category")]
    pub category: Label,

    /// If `true`, this asset counts as an impact (Starforged) or a debility
    /// (classic Ironsworn).
    #[serde(rename = "count_as_impact")]
    pub countAsImpact: bool,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Most assets only benefit to their owner, but certain assets (like
    /// Starforged's module and command vehicle assets) are shared amongst the
    /// player's allies, too.
    #[serde(rename = "shared")]
    pub shared: bool,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    #[serde(rename = "attachments")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attachments: Option<Box<AssetAttachment>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this asset.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// Controls are condition meters, clocks, counters, and other asset input
    /// fields whose values are expected to change throughout the life of the
    /// asset.
    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, AssetControlField>>>,

    /// This asset's icon.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Options are input fields set when the player purchases the asset.
    /// They're likely to remain the same through the life of the asset.
    /// Typically, they are rendered at the top of the asset card.
    #[serde(rename = "options")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub options: Option<Box<HashMap<String, AssetOptionField>>>,

    /// Describes prerequisites for purchasing or using this asset.
    #[serde(rename = "requirement")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requirement: Option<Box<MarkdownString>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

/// An asset ability: one of the purchasable features of an asset. Most assets
/// have three.
#[derive(Serialize, Deserialize)]
pub struct AssetAbility {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: AssetAbilityId,

    /// Is this asset ability enabled?
    #[serde(rename = "enabled")]
    pub enabled: bool,

    /// The complete rules text of this asset ability.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// Fields whose values are expected to change over the life of the asset.
    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, AssetAbilityControlField>>>,

    /// Changes made to the asset, when this ability is enabled.
    #[serde(rename = "enhance_asset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceAsset: Option<Box<AssetEnhancement>>,

    /// Describes changes made to various moves by this asset ability. Usually
    /// these require specific trigger conditions.
    #[serde(rename = "enhance_moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceMoves: Option<Box<Vec<MoveEnhancement>>>,

    /// Unique moves added by this asset ability.
    #[serde(rename = "moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moves: Option<Box<HashMap<String, Move>>>,

    /// A handful of asset abilities have a label/name, for instance classic
    /// Ironsworn companion assets. Most canonical assets omit this property.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<Box<Label>>,

    /// Fields that are expected to be set once and remain the same through the
    /// life of the asset.
    #[serde(rename = "options")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub options: Option<Box<HashMap<String, AssetAbilityOptionField>>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetAbilityControlField {
    #[serde(rename = "checkbox")]
    Checkbox(AssetAbilityControlFieldCheckbox),

    #[serde(rename = "clock")]
    Clock(AssetAbilityControlFieldClock),

    #[serde(rename = "counter")]
    Counter(AssetAbilityControlFieldCounter),

    #[serde(rename = "text")]
    Text(AssetAbilityControlFieldText),
}

#[derive(Serialize, Deserialize)]
pub struct AssetAbilityControlFieldCheckbox {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// Is the box checked?
    #[serde(rename = "value")]
    pub value: bool,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

/// A clock with 4 or more segments.
#[derive(Serialize, Deserialize)]
pub struct AssetAbilityControlFieldClock {
    #[serde(rename = "label")]
    pub label: InputLabel,

    /// The size of the clock -- in other words, the maximum number of filled
    /// clock segments. Standard clocks have 4, 6, 8, or 10 segments.
    #[serde(rename = "max")]
    pub max: i8,

    /// The minimum number of filled clock segments. This is always 0.
    #[serde(rename = "min")]
    pub min: i8,

    #[serde(rename = "rollable")]
    pub rollable: bool,

    /// The current value of this input.
    #[serde(rename = "value")]
    pub value: i8,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

/// A basic counter representing a non-rollable integer value. They usually
/// start at 0, and may or may not have a maximum.
#[derive(Serialize, Deserialize)]
pub struct AssetAbilityControlFieldCounter {
    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "max")]
    pub max: i16,

    /// The (inclusive) minimum value.
    #[serde(rename = "min")]
    pub min: i8,

    #[serde(rename = "rollable")]
    pub rollable: bool,

    /// The current value of this input.
    #[serde(rename = "value")]
    pub value: i8,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

/// Represents an input that accepts plain text.
#[derive(Serialize, Deserialize)]
pub struct AssetAbilityControlFieldText {
    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "value")]
    pub value: String,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

/// A unique ID for an AssetAbility.
pub type AssetAbilityId = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetAbilityOptionField {
    #[serde(rename = "text")]
    Text(AssetAbilityOptionFieldText),
}

/// Represents an input that accepts plain text.
#[derive(Serialize, Deserialize)]
pub struct AssetAbilityOptionFieldText {
    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "value")]
    pub value: String,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

/// Describes which assets can be attached to this asset. Example: Starforged's
/// Module assets, which can be equipped by Command Vehicle assets. See p. 55 of
/// Starforged for more info.
#[derive(Serialize, Deserialize)]
pub struct AssetAttachment {
    /// Asset IDs (which may be wildcards) that may be attached to this asset
    #[serde(rename = "assets")]
    pub assets: Vec<AssetIdWildcard>,

    #[serde(rename = "max")]
    pub max: i16,
}

#[derive(Serialize, Deserialize)]
pub struct AssetCollection {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: AssetCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this collection.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<Box<HashMap<String, Asset>>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This collection's content enhances the identified collection, rather
    /// than being a standalone collection of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<AssetCollectionId>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This collection replaces the identified collection. References to the
    /// replaced collection can be considered equivalent to this collection.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<AssetCollectionId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

/// A unique ID for an AssetCollection.
pub type AssetCollectionId = String;

/// A checkbox control field, rendered as part of an asset condition meter.
#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetConditionMeterControlField {
    #[serde(rename = "card_flip")]
    CardFlip(AssetConditionMeterControlFieldCardFlip),

    #[serde(rename = "checkbox")]
    Checkbox(AssetConditionMeterControlFieldCheckbox),
}

#[derive(Serialize, Deserialize)]
pub struct AssetConditionMeterControlFieldCardFlip {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// Is the card flipped over?
    #[serde(rename = "value")]
    pub value: bool,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

#[derive(Serialize, Deserialize)]
pub struct AssetConditionMeterControlFieldCheckbox {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// Is the box checked?
    #[serde(rename = "value")]
    pub value: bool,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetControlField {
    #[serde(rename = "card_flip")]
    CardFlip(AssetControlFieldCardFlip),

    #[serde(rename = "checkbox")]
    Checkbox(AssetControlFieldCheckbox),

    #[serde(rename = "condition_meter")]
    ConditionMeter(AssetControlFieldConditionMeter),

    #[serde(rename = "select_enhancement")]
    SelectEnhancement(AssetControlFieldSelectEnhancement),
}

#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldCardFlip {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// Is the card flipped over?
    #[serde(rename = "value")]
    pub value: bool,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldCheckbox {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// Is the box checked?
    #[serde(rename = "value")]
    pub value: bool,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

/// Provides hints for moves that interact with this condition meter, such as
/// suffer and recovery moves.
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldConditionMeterMoves {
    /// The ID(s) of recovery moves associated with this meter.
    #[serde(rename = "recover")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recover: Option<Box<Vec<MoveIdWildcard>>>,

    /// The ID(s) of suffer moves associated with the condition meter. If the
    /// suffer move makes an action roll, this condition meter value should be
    /// made available as a roll option.
    #[serde(rename = "suffer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suffer: Option<Box<Vec<MoveIdWildcard>>>,
}

/// Some assets provide a special condition meter of their own. The most common
/// example is the health meters on companion assets. Asset condition meters
/// may also include their own controls, such as the checkboxes that Starforged
/// companion assets use to indicate they are "out of action".
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldConditionMeter {
    #[serde(rename = "label")]
    pub label: InputLabel,

    /// The maximum value of this meter.
    #[serde(rename = "max")]
    pub max: i8,

    /// The minimum value of this meter.
    #[serde(rename = "min")]
    pub min: i8,

    /// Is this meter's `value` usable as a stat in an action roll?
    #[serde(rename = "rollable")]
    pub rollable: bool,

    /// The current value of this meter.
    #[serde(rename = "value")]
    pub value: i8,

    /// Checkbox controls rendered as part of the condition meter.
    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, AssetConditionMeterControlField>>>,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Provides hints for moves that interact with this condition meter, such
    /// as suffer and recovery moves.
    #[serde(rename = "moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moves: Option<Box<AssetControlFieldConditionMeterMoves>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "choice_type")]
pub enum AssetControlFieldSelectEnhancementChoice {
    #[serde(rename = "choice")]
    Choice(AssetControlFieldSelectEnhancementChoiceChoice),

    #[serde(rename = "choice_group")]
    ChoiceGroup(AssetControlFieldSelectEnhancementChoiceChoiceGroup),
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldSelectEnhancementChoiceChoice {
    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "enhance_asset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceAsset: Option<Box<AssetEnhancement>>,

    #[serde(rename = "enhance_moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceMoves: Option<Box<Vec<MoveEnhancement>>>,
}

/// Represents a grouping of options in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldSelectEnhancementChoiceChoiceGroup {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, SelectEnhancementFieldChoice>,

    /// A label for this option group.
    #[serde(rename = "name")]
    pub name: InputLabel,
}

/// Select from player and/or asset enhancements. Use it to describe modal
/// abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
/// (Sundered Isles).
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldSelectEnhancement {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, AssetControlFieldSelectEnhancementChoice>,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// The key of the currently selected choice from the `choices` property, or
    /// `null` if none is selected.
    #[serde(rename = "value")]
    pub value: DictKey,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetControlFieldEnhancement {
    #[serde(rename = "condition_meter")]
    ConditionMeter(AssetControlFieldEnhancementConditionMeter),
}

/// Some assets provide a special condition meter of their own. The most common
/// example is the health meters on companion assets. Asset condition meters
/// may also include their own controls, such as the checkboxes that Starforged
/// companion assets use to indicate they are "out of action".
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldEnhancementConditionMeter {
    /// The maximum value of this meter.
    #[serde(rename = "max")]
    pub max: i8,
}

/// Describes enhancements made to this asset in a partial asset object. The
/// changes should be applied recursively; only the values that are specified
/// should be changed.
#[derive(Serialize, Deserialize)]
pub struct AssetEnhancement {
    #[serde(rename = "attachments")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attachments: Option<Box<AssetAttachment>>,

    /// Controls are condition meters, clocks, counters, and other asset input
    /// fields whose values are expected to change throughout the life of the
    /// asset.
    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, AssetControlFieldEnhancement>>>,

    /// If `true`, this asset counts as an impact (Starforged) or a debility
    /// (classic Ironsworn).
    #[serde(rename = "count_as_impact")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub countAsImpact: Option<Box<bool>>,

    /// Most assets only benefit to their owner, but certain assets (like
    /// Starforged's module and command vehicle assets) are shared amongst the
    /// player's allies, too.
    #[serde(rename = "shared")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared: Option<Box<bool>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

/// A unique ID for an Asset.
pub type AssetId = String;

/// A wildcarded ID that can be used to match multiple Assets.
pub type AssetIdWildcard = String;

/// Options are asset input fields which are set once, usually when the
/// character takes the asset. The most common example is the "name" field on
/// companion assets. A more complex example is the choice of a god's stat for
/// the Devotant asset.
#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetOptionField {
    #[serde(rename = "select_enhancement")]
    SelectEnhancement(AssetOptionFieldSelectEnhancement),

    #[serde(rename = "select_value")]
    SelectValue(AssetOptionFieldSelectValue),

    #[serde(rename = "text")]
    Text(AssetOptionFieldText),
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "choice_type")]
pub enum AssetOptionFieldSelectEnhancementChoice {
    #[serde(rename = "choice")]
    Choice(AssetOptionFieldSelectEnhancementChoiceChoice),

    #[serde(rename = "choice_group")]
    ChoiceGroup(AssetOptionFieldSelectEnhancementChoiceChoiceGroup),
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectEnhancementChoiceChoice {
    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "enhance_asset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceAsset: Option<Box<AssetEnhancement>>,

    #[serde(rename = "enhance_moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceMoves: Option<Box<Vec<MoveEnhancement>>>,
}

/// Represents a grouping of options in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectEnhancementChoiceChoiceGroup {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, SelectEnhancementFieldChoice>,

    /// A label for this option group.
    #[serde(rename = "name")]
    pub name: InputLabel,
}

/// Select from player and/or asset enhancements. Use it to describe modal
/// abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
/// (Sundered Isles).
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectEnhancement {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, AssetOptionFieldSelectEnhancementChoice>,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// The key of the currently selected choice from the `choices` property, or
    /// `null` if none is selected.
    #[serde(rename = "value")]
    pub value: DictKey,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

/// Represents a list of mutually exclusive choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectValue {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, SelectValueFieldChoice>,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// The key of the currently selected choice from the `choices` property, or
    /// `null` if none is selected.
    #[serde(rename = "value")]
    pub value: DictKey,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

/// Represents an input that accepts plain text.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldText {
    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "value")]
    pub value: String,

    /// An icon associated with this input.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,
}

#[derive(Serialize, Deserialize)]
pub struct Atlas {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: AtlasId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "collections")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub collections: Option<Box<HashMap<String, Atlas>>>,

    /// A thematic color associated with this collection.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<Box<HashMap<String, AtlasEntry>>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This collection's content enhances the identified collection, rather
    /// than being a standalone collection of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<AtlasId>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This collection replaces the identified collection. References to the
    /// replaced collection can be considered equivalent to this collection.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<AtlasId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

/// An atlas entry, like the Ironlands region entries found in classic
/// Ironsworn.
#[derive(Serialize, Deserialize)]
pub struct AtlasEntry {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: AtlasEntryId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "features")]
    pub features: Vec<MarkdownString>,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "quest_starter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub questStarter: Option<Box<MarkdownString>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,

    #[serde(rename = "your_truth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub yourTruth: Option<Box<MarkdownString>>,
}

/// A unique ID for an AtlasEntry.
pub type AtlasEntryId = String;

/// A unique ID for an Atlas.
pub type AtlasId = String;

/// Information on the original creator of this material.
#[derive(Serialize, Deserialize)]
pub struct AuthorInfo {
    #[serde(rename = "name")]
    pub name: String,

    /// An optional email contact for the author
    #[serde(rename = "email")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<Box<String>>,

    /// An optional URL for the author's website.
    #[serde(rename = "url")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<Box<String>>,
}

/// Challenge rank, represented as an integer from 1 (troublesome) to 5 (epic).
pub type ChallengeRank = u8;

/// A basic, rollable player character resource specified by the ruleset.
pub type ConditionMeterKey = DictKey;

/// Describes a standard player character condition meter.
#[derive(Serialize, Deserialize)]
pub struct ConditionMeterRule {
    /// A description of this condition meter.
    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// The maximum value of this meter.
    #[serde(rename = "max")]
    pub max: i8,

    /// The minimum value of this meter.
    #[serde(rename = "min")]
    pub min: i8,

    /// Is this meter's `value` usable as a stat in an action roll?
    #[serde(rename = "rollable")]
    pub rollable: bool,

    /// Is this condition meter shared by all players?
    #[serde(rename = "shared")]
    pub shared: bool,

    /// The current value of this meter.
    #[serde(rename = "value")]
    pub value: i8,
}

/// A CSS color value.
pub type CssColor = String;

/// A delve site with a theme, domain, and denizens.
#[derive(Serialize, Deserialize)]
pub struct DelveSite {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: DelveSiteId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "denizens")]
    pub denizens: Vec<DelveSiteDenizen>,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "domain")]
    pub domain: DelveSiteDomainId,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "rank")]
    pub rank: ChallengeRank,

    #[serde(rename = "theme")]
    pub theme: DelveSiteThemeId,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// An additional theme or domain card ID, for use with optional rules in
    /// Ironsworn: Delve.
    #[serde(rename = "extra_card")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extraCard: Option<Box<String>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// The ID of an atlas entry representing the region in which this delve
    /// site is located.
    #[serde(rename = "region")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub region: Option<Box<AtlasEntryId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

#[derive(Serialize, Deserialize)]
pub struct DelveSiteDenizen {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: DelveSiteDenizenId,

    #[serde(rename = "frequency")]
    pub frequency: DelveSiteDenizenFrequency,

    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<Box<Label>>,

    /// The ID of the relevant NPC entry, if one is specified.
    #[serde(rename = "npc")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub npc: Option<Box<NpcId>>,
}

#[derive(Serialize, Deserialize)]
pub enum DelveSiteDenizenFrequency {
    #[serde(rename = "common")]
    Common,

    #[serde(rename = "rare")]
    Rare,

    #[serde(rename = "uncommon")]
    Uncommon,

    #[serde(rename = "unforeseen")]
    Unforeseen,

    #[serde(rename = "very_common")]
    VeryCommon,
}

/// A unique ID for a DelveSiteDenizen.
pub type DelveSiteDenizenId = String;

/// A delve site Domain card.
#[derive(Serialize, Deserialize)]
pub struct DelveSiteDomain {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: DelveSiteDomainId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "dangers")]
    pub dangers: Vec<DelveSiteDomainDangerRow>,

    #[serde(rename = "features")]
    pub features: Vec<DelveSiteDomainFeatureRow>,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "summary")]
    pub summary: MarkdownString,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// An oracle table ID containing place name elements. For examples, see
    /// oracle ID `delve/oracles/site_name/place/barrow`, and its siblings in
    /// oracle collection ID `delve/collections/oracles/site_name/place`. These
    /// oracles are used by the site name oracle from Ironsworn: Delve (ID:
    /// delve/oracles/site_name/format) to create random names for delve sites.
    #[serde(rename = "name_oracle")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nameOracle: Option<Box<OracleRollableId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

/// Represents a single Danger entry from a delve site Domain card.
#[derive(Serialize, Deserialize)]
pub struct DelveSiteDomainDangerRow {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: DomainDangerRowId,

    /// High end of the dice range for this table row.
    #[serde(rename = "max")]
    pub max: i16,

    /// Low end of the dice range for this table row.
    #[serde(rename = "min")]
    pub min: i16,

    /// The primary text content of this row.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    #[serde(rename = "_i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleRollableId>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "oracle_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracleRolls: Option<Box<Vec<OracleRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// Represents a single Feature entry from a delve site Domain card.
#[derive(Serialize, Deserialize)]
pub struct DelveSiteDomainFeatureRow {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: DomainFeatureRowId,

    /// High end of the dice range for this table row.
    #[serde(rename = "max")]
    pub max: i16,

    /// Low end of the dice range for this table row.
    #[serde(rename = "min")]
    pub min: i16,

    /// The primary text content of this row.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    #[serde(rename = "_i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleRollableId>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "oracle_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracleRolls: Option<Box<Vec<OracleRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// A unique ID for a DelveSiteDomain.
pub type DelveSiteDomainId = String;

/// A unique ID for a DelveSite.
pub type DelveSiteId = String;

/// A delve site theme card.
#[derive(Serialize, Deserialize)]
pub struct DelveSiteTheme {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: DelveSiteThemeId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "dangers")]
    pub dangers: Vec<DelveSiteThemeDangerRow>,

    #[serde(rename = "features")]
    pub features: Vec<DelveSiteThemeFeatureRow>,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "summary")]
    pub summary: MarkdownString,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

/// Represents a single Danger entry from a delve site Theme card.
#[derive(Serialize, Deserialize)]
pub struct DelveSiteThemeDangerRow {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: ThemeDangerRowId,

    /// High end of the dice range for this table row.
    #[serde(rename = "max")]
    pub max: i16,

    /// Low end of the dice range for this table row.
    #[serde(rename = "min")]
    pub min: i16,

    /// The primary text content of this row.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    #[serde(rename = "_i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleRollableId>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "oracle_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracleRolls: Option<Box<Vec<OracleRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// Represents a single Feature entry from a delve site Theme card.
#[derive(Serialize, Deserialize)]
pub struct DelveSiteThemeFeatureRow {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: ThemeFeatureRowId,

    /// High end of the dice range for this table row.
    #[serde(rename = "max")]
    pub max: i16,

    /// Low end of the dice range for this table row.
    #[serde(rename = "min")]
    pub min: i16,

    /// The primary text content of this row.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    #[serde(rename = "_i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleRollableId>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "oracle_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracleRolls: Option<Box<Vec<OracleRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// A unique ID for a DelveSiteTheme.
pub type DelveSiteThemeId = String;

/// A simple dice roll expression with an optional modifer.
pub type DiceExpression = String;

/// A `snake_case` key used in a Datasworn dictionary object.
pub type DictKey = String;

/// A unique ID for a DomainDangerRow.
pub type DomainDangerRowId = String;

/// A unique ID for a DomainFeatureRow.
pub type DomainFeatureRowId = String;

/// The ID of a Datasworn package that relies on an external package to provide
/// its ruleset.
pub type ExpansionId = String;

#[derive(Serialize, Deserialize)]
pub struct I18nHint {
    /// The part of speech for this string.
    #[serde(rename = "part_of_speech")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partOfSpeech: Option<Box<PartOfSpeech>>,
}

#[derive(Serialize, Deserialize)]
pub struct I18nHintsTemplate {
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<I18nHint>>,

    #[serde(rename = "text2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text2: Option<Box<I18nHint>>,

    #[serde(rename = "text3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text3: Option<Box<I18nHint>>,
}

/// Internationalization/localization hints for the text content of this object.
#[derive(Serialize, Deserialize)]
pub struct I18nHints {
    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<I18nHintsTemplate>>,

    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<I18nHint>>,

    #[serde(rename = "text2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text2: Option<Box<I18nHint>>,

    #[serde(rename = "text3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text3: Option<Box<I18nHint>>,
}

/// Describes a category of standard impacts/debilities.
#[derive(Serialize, Deserialize)]
pub struct ImpactCategory {
    /// A dictionary object of the Impacts in this category.
    #[serde(rename = "contents")]
    pub contents: HashMap<String, ImpactRule>,

    /// A description of this impact category.
    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// A label for this impact category.
    #[serde(rename = "label")]
    pub label: InputLabel,
}

/// Describes a standard impact/debility.
#[derive(Serialize, Deserialize)]
pub struct ImpactRule {
    /// A description of this impact.
    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// The label for this impact.
    #[serde(rename = "label")]
    pub label: InputLabel,

    /// Is this impact permanent?
    #[serde(rename = "permanent")]
    pub permanent: bool,

    /// Any ruleset condition meters that can't recover when this impact is
    /// active.
    #[serde(rename = "prevents_recovery")]
    pub preventsRecovery: Vec<ConditionMeterKey>,

    /// Is this impact applied to all players at once?
    #[serde(rename = "shared")]
    pub shared: bool,
}

/// A localized label for an input. In some contexts it may be undesirable to
/// render this text, but it should always be exposed to assistive technology
/// (e.g. with `aria-label` in HTML).
pub type InputLabel = String;

/// A localized plain text name or label.
pub type Label = String;

/// An URL pointing to the location where this element's license can be found.
/// 
/// A `null` here indicates that the content provides __no__ license, and is not
/// intended for redistribution.
pub type License = WebUrl;

/// Localized text, formatted in Markdown.
/// 
/// It uses some custom syntax; e.g. `{{table:some_oracle_table_id}}` indicates
/// that the referenced oracle table is rendered there part of the source
/// material.
pub type MarkdownString = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "roll_type")]
pub enum Move {
    #[serde(rename = "action_roll")]
    ActionRoll(MoveActionRoll),

    #[serde(rename = "no_roll")]
    NoRoll(MoveNoRoll),

    #[serde(rename = "progress_roll")]
    ProgressRoll(MoveProgressRoll),

    #[serde(rename = "special_track")]
    SpecialTrack(MoveSpecialTrack),
}

/// A move that makes an action roll.
#[derive(Serialize, Deserialize)]
pub struct MoveActionRoll {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: MoveId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerActionRoll,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// Oracles associated with this move. It's not recommended to roll these
    /// automatically, as almost all moves present them as an option, not
    /// a requirement.
    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<Vec<OracleRollableId>>>,

    /// Indicates that this move replaces the identified move. References to the
    /// replaced move can be considered equivalent to this move.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<MoveId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

/// A move that makes no progress rolls or action rolls.
#[derive(Serialize, Deserialize)]
pub struct MoveNoRoll {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: MoveId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerNoRoll,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// Oracles associated with this move. It's not recommended to roll these
    /// automatically, as almost all moves present them as an option, not
    /// a requirement.
    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<Vec<OracleRollableId>>>,

    /// Indicates that this move replaces the identified move. References to the
    /// replaced move can be considered equivalent to this move.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<MoveId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

/// A progress move that rolls on a standard progress track type (whose features
/// are defined by this move object). For progress rolls that use special
/// tracks, see MoveSpecialTrack.
#[derive(Serialize, Deserialize)]
pub struct MoveProgressRoll {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: MoveId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Describes the common features of progress tracks associated with this
    /// move.
    #[serde(rename = "tracks")]
    pub tracks: ProgressTrackTypeInfo,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerProgressRoll,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// Oracles associated with this move. It's not recommended to roll these
    /// automatically, as almost all moves present them as an option, not
    /// a requirement.
    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<Vec<OracleRollableId>>>,

    /// Indicates that this move replaces the identified move. References to the
    /// replaced move can be considered equivalent to this move.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<MoveId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

/// A progress move that rolls on a special track, such as Legacies (Starforged)
/// or Bonds (classic Ironsworn). For progress moves that use standard progress
/// tracks, see MoveProgressRoll instead.
#[derive(Serialize, Deserialize)]
pub struct MoveSpecialTrack {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: MoveId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Trigger conditions for this move.
    #[serde(rename = "trigger")]
    pub trigger: TriggerSpecialTrack,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// Oracles associated with this move. It's not recommended to roll these
    /// automatically, as almost all moves present them as an option, not
    /// a requirement.
    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<Vec<OracleRollableId>>>,

    /// Indicates that this move replaces the identified move. References to the
    /// replaced move can be considered equivalent to this move.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<MoveId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveCategory {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: MoveCategoryId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this collection.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<Box<HashMap<String, Move>>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This collection's content enhances the identified collection, rather
    /// than being a standalone collection of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<MoveCategoryId>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This collection replaces the identified collection. References to the
    /// replaced collection can be considered equivalent to this collection.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<MoveCategoryId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

/// A unique ID for a MoveCategory.
pub type MoveCategoryId = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "roll_type")]
pub enum MoveEnhancement {
    #[serde(rename = "action_roll")]
    ActionRoll(MoveEnhancementActionRoll),

    #[serde(rename = "no_roll")]
    NoRoll(MoveEnhancementNoRoll),

    #[serde(rename = "progress_roll")]
    ProgressRoll(MoveEnhancementProgressRoll),

    #[serde(rename = "special_track")]
    SpecialTrack(MoveEnhancementSpecialTrack),
}

/// An object that describes changes to a move. These changes should be applied
/// recursively, altering only the specified properties; enhanced arrays should
/// be concatencated with the original array value.
#[derive(Serialize, Deserialize)]
pub struct MoveEnhancementActionRoll {
    #[serde(rename = "enhances")]
    pub enhances: Vec<MoveIdWildcard>,

    #[serde(rename = "trigger")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Box<TriggerActionRollEnhancement>>,
}

/// An object that describes changes to a move. These changes should be applied
/// recursively, altering only the specified properties; enhanced arrays should
/// be concatencated with the original array value.
#[derive(Serialize, Deserialize)]
pub struct MoveEnhancementNoRoll {
    #[serde(rename = "enhances")]
    pub enhances: Vec<MoveIdWildcard>,

    #[serde(rename = "trigger")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Box<TriggerNoRollEnhancement>>,
}

/// An object that describes changes to a move. These changes should be applied
/// recursively, altering only the specified properties; enhanced arrays should
/// be concatencated with the original array value.
#[derive(Serialize, Deserialize)]
pub struct MoveEnhancementProgressRoll {
    #[serde(rename = "enhances")]
    pub enhances: Vec<MoveIdWildcard>,

    #[serde(rename = "trigger")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Box<TriggerProgressRollEnhancement>>,
}

/// An object that describes changes to a move. These changes should be applied
/// recursively, altering only the specified properties; enhanced arrays should
/// be concatencated with the original array value.
#[derive(Serialize, Deserialize)]
pub struct MoveEnhancementSpecialTrack {
    #[serde(rename = "enhances")]
    pub enhances: Vec<MoveIdWildcard>,

    #[serde(rename = "trigger")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Box<TriggerSpecialTrackEnhancement>>,
}

/// A move ID, for a standard move or a unique asset move
pub type MoveId = String;

/// A move ID with wildcards.
pub type MoveIdWildcard = String;

#[derive(Serialize, Deserialize)]
pub struct MoveOutcome {
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "oracle_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracleRolls: Option<Box<Vec<OracleRoll>>>,
}

/// A standalone localized description for each move outcome (miss, weak hit,
/// or strong hit). This is for for e.g. VTT implementations, where it's often
/// useful to display only the rules text relevant to a roll result.
/// 
///   This often requires light editorialization to create text that can stand
/// alone without reference to the rest of the move. For example, 'as above'
/// (in reference to another move outcome) shouldn't be used here; instead, the
/// relevant text should be repeated.
#[derive(Serialize, Deserialize)]
pub struct MoveOutcomes {
    #[serde(rename = "miss")]
    pub miss: MoveOutcome,

    #[serde(rename = "strong_hit")]
    pub strongHit: MoveOutcome,

    #[serde(rename = "weak_hit")]
    pub weakHit: MoveOutcome,
}

/// A non-player character entry, similar to those in Chapter 5 of the Ironsworn
/// Rulebook, or Chapter 4 of Starforged.
#[derive(Serialize, Deserialize)]
pub struct Npc {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: NpcId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "drives")]
    pub drives: Vec<MarkdownString>,

    #[serde(rename = "features")]
    pub features: Vec<MarkdownString>,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "nature")]
    pub nature: NpcNature,

    /// The suggested challenge rank for this NPC.
    #[serde(rename = "rank")]
    pub rank: ChallengeRank,

    #[serde(rename = "tactics")]
    pub tactics: Vec<MarkdownString>,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "quest_starter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub questStarter: Option<Box<MarkdownString>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,

    #[serde(rename = "variants")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub variants: Option<Box<HashMap<String, NpcVariant>>>,

    #[serde(rename = "your_truth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub yourTruth: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct NpcCollection {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: NpcCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this collection.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<Box<HashMap<String, Npc>>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This collection's content enhances the identified collection, rather
    /// than being a standalone collection of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<NpcCollectionId>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This collection replaces the identified collection. References to the
    /// replaced collection can be considered equivalent to this collection.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<NpcCollectionId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

/// A unique ID for a NpcCollection.
pub type NpcCollectionId = String;

/// A unique ID for a Npc.
pub type NpcId = String;

/// A localized category label describing the nature of this NPC.
/// 
/// In Ironsworn classic, this is probably the singular form of the parent
/// collection's name.
/// 
/// For Starforged, see the table on p. 258 for examples.
pub type NpcNature = Label;

#[derive(Serialize, Deserialize)]
pub struct NpcVariant {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: NpcVariantId,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "nature")]
    pub nature: NpcNature,

    /// The suggested challenge rank for this NPC.
    #[serde(rename = "rank")]
    pub rank: ChallengeRank,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,
}

/// A unique ID for a NpcVariant.
pub type NpcVariantId = String;

#[derive(Serialize, Deserialize)]
pub enum ObjectType {
    #[serde(rename = "asset")]
    Asset,

    #[serde(rename = "asset_collection")]
    AssetCollection,

    #[serde(rename = "atlas")]
    Atlas,

    #[serde(rename = "atlas_entry")]
    AtlasEntry,

    #[serde(rename = "delve_site")]
    DelveSite,

    #[serde(rename = "delve_site_domain")]
    DelveSiteDomain,

    #[serde(rename = "delve_site_theme")]
    DelveSiteTheme,

    #[serde(rename = "move")]
    Move,

    #[serde(rename = "move_category")]
    MoveCategory,

    #[serde(rename = "npc")]
    Npc,

    #[serde(rename = "npc_collection")]
    NpcCollection,

    #[serde(rename = "oracle_collection")]
    OracleCollection,

    #[serde(rename = "oracle_rollable")]
    OracleRollable,

    #[serde(rename = "rarity")]
    Rarity,

    #[serde(rename = "truth")]
    Truth,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "oracle_type")]
pub enum OracleCollection {
    #[serde(rename = "table_shared_rolls")]
    TableSharedRolls(OracleCollectionTableSharedRolls),

    #[serde(rename = "table_shared_text")]
    TableSharedText(OracleCollectionTableSharedText),

    #[serde(rename = "table_shared_text2")]
    TableSharedText2(OracleCollectionTableSharedText2),

    #[serde(rename = "table_shared_text3")]
    TableSharedText3(OracleCollectionTableSharedText3),

    #[serde(rename = "tables")]
    Tables(OracleCollectionTables),
}

/// Provides column labels for this table. The `roll` key refers to the roll
/// column showing the dice range (`min` and `max` on each table row). For all
/// other column labels, see the `name` property of each child `OracleColumn`.
#[derive(Serialize, Deserialize)]
pub struct OracleCollectionTableSharedRollsColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,
}

/// An OracleCollection representing a single table with one roll column and
/// multiple `result` columns.
#[derive(Serialize, Deserialize)]
pub struct OracleCollectionTableSharedRolls {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: OracleCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// Provides column labels for this table. The `roll` key refers to the
    /// roll column showing the dice range (`min` and `max` on each table row).
    /// For all other column labels, see the `name` property of each child
    /// `OracleColumn`.
    #[serde(rename = "column_labels")]
    pub columnLabels: OracleCollectionTableSharedRollsColumnLabels,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this collection.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<Box<HashMap<String, OracleColumnText>>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This collection's content enhances the identified collection, rather
    /// than being a standalone collection of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<OracleCollectionId>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This collection replaces the identified collection. References to the
    /// replaced collection can be considered equivalent to this collection.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<OracleCollectionId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

/// The label at the head of each table column. The `roll` key refers to the
/// roll column showing the dice range (`min` and `max` on each table row).
#[derive(Serialize, Deserialize)]
pub struct OracleCollectionTableSharedTextColumnLabels {
    #[serde(rename = "text")]
    pub text: Label,
}

/// An OracleCollection representing a single table with multiple roll columns
/// and one `result` column.
#[derive(Serialize, Deserialize)]
pub struct OracleCollectionTableSharedText {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: OracleCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// The label at the head of each table column. The `roll` key refers to the
    /// roll column showing the dice range (`min` and `max` on each table row).
    #[serde(rename = "column_labels")]
    pub columnLabels: OracleCollectionTableSharedTextColumnLabels,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this collection.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<Box<HashMap<String, OracleColumnText>>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This collection's content enhances the identified collection, rather
    /// than being a standalone collection of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<OracleCollectionId>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This collection replaces the identified collection. References to the
    /// replaced collection can be considered equivalent to this collection.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<OracleCollectionId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

/// The label at the head of each table column. The `roll` key refers to the
/// roll column showing the dice range (`min` and `max` on each table row).
#[derive(Serialize, Deserialize)]
pub struct OracleCollectionTableSharedText2ColumnLabels {
    #[serde(rename = "text")]
    pub text: Label,

    #[serde(rename = "text2")]
    pub text2: Label,
}

/// An OracleCollection representing a single table with multiple roll columns,
/// and 2 shared text columns.
#[derive(Serialize, Deserialize)]
pub struct OracleCollectionTableSharedText2 {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: OracleCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// The label at the head of each table column. The `roll` key refers to the
    /// roll column showing the dice range (`min` and `max` on each table row).
    #[serde(rename = "column_labels")]
    pub columnLabels: OracleCollectionTableSharedText2ColumnLabels,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this collection.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<Box<HashMap<String, OracleColumnText2>>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This collection's content enhances the identified collection, rather
    /// than being a standalone collection of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<OracleCollectionId>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This collection replaces the identified collection. References to the
    /// replaced collection can be considered equivalent to this collection.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<OracleCollectionId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

/// The label at the head of each table column. The `roll` key refers to the
/// roll column showing the dice range (`min` and `max` on each table row).
#[derive(Serialize, Deserialize)]
pub struct OracleCollectionTableSharedText3ColumnLabels {
    #[serde(rename = "text")]
    pub text: Label,
}

/// An OracleCollection representing a single table with multiple roll columns,
/// and 2 shared text columns.
#[derive(Serialize, Deserialize)]
pub struct OracleCollectionTableSharedText3 {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: OracleCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// The label at the head of each table column. The `roll` key refers to the
    /// roll column showing the dice range (`min` and `max` on each table row).
    #[serde(rename = "column_labels")]
    pub columnLabels: OracleCollectionTableSharedText3ColumnLabels,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A thematic color associated with this collection.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<Box<HashMap<String, OracleColumnText2>>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This collection's content enhances the identified collection, rather
    /// than being a standalone collection of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<OracleCollectionId>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This collection replaces the identified collection. References to the
    /// replaced collection can be considered equivalent to this collection.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<OracleCollectionId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

/// An OracleCollection that represents a category or grouping of tables, which
/// may themselves be `OracleTablesCollection`s.
#[derive(Serialize, Deserialize)]
pub struct OracleCollectionTables {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: OracleCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "collections")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub collections: Option<Box<HashMap<String, OracleCollection>>>,

    /// A thematic color associated with this collection.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<Box<HashMap<String, OracleTableRollable>>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This collection's content enhances the identified collection, rather
    /// than being a standalone collection of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<OracleCollectionId>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This collection replaces the identified collection. References to the
    /// replaced collection can be considered equivalent to this collection.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<OracleCollectionId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

/// A unique ID for an OracleCollection.
pub type OracleCollectionId = String;

#[derive(Serialize, Deserialize)]
pub enum OracleColumnTextOracleType {
    #[serde(rename = "column_text")]
    ColumnText,
}

/// Represents a single column in an OracleCollection.
#[derive(Serialize, Deserialize)]
pub struct OracleColumnText {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: OracleRollableId,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary label at the head of this column.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "oracle_type")]
    pub oracleType: OracleColumnTextOracleType,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleTableRowText>,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// An optional thematic color for this column. For an example, see "Basic
    /// Creature Form" (Starforged p. 337)
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An optional icon for this column.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    /// Indicates that this object replaces the identified OracleRollable.
    /// References to the replaced object can be considered equivalent to this
    /// object.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<OracleRollableId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// Optional secondary text at the head of this column. For best results,
    /// this should be no more than a few words in length.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

#[derive(Serialize, Deserialize)]
pub enum OracleColumnText2OracleType {
    #[serde(rename = "column_text2")]
    ColumnText2,
}

#[derive(Serialize, Deserialize)]
pub struct OracleColumnText2 {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: OracleRollableId,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary label at the head of this column.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "oracle_type")]
    pub oracleType: OracleColumnText2OracleType,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleTableRowText2>,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// An optional thematic color for this column. For an example, see "Basic
    /// Creature Form" (Starforged p. 337)
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    /// An optional icon for this column.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    /// Indicates that this object replaces the identified OracleRollable.
    /// References to the replaced object can be considered equivalent to this
    /// object.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<OracleRollableId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// Optional secondary text at the head of this column. For best results,
    /// this should be no more than a few words in length.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

/// Special roll instructions to use when rolling multiple times on a single
/// oracle.
#[derive(Serialize, Deserialize)]
pub enum OracleDuplicateBehavior {
    /// Duplicates results should be kept.
    #[serde(rename = "keep")]
    Keep,

    /// Duplicate results should be kept, and they compound to make things
    /// worse.
    #[serde(rename = "make_it_worse")]
    MakeItWorse,

    /// Duplicate results should be re-rolled.
    #[serde(rename = "reroll")]
    Reroll,
}

#[derive(Serialize, Deserialize)]
pub struct OracleMatchBehavior {
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct OracleRoll {
    /// Both Ironsworn and Starforged explicitly recommend *against* rolling
    /// all details at once. That said, some oracle results only provide useful
    /// information once a secondary roll occurs, such as "Action + Theme" or
    /// "Roll twice".
    #[serde(rename = "auto")]
    pub auto: bool,

    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// Special rules on how to handle duplicate results, when rolling multiple
    /// times.
    #[serde(rename = "duplicates")]
    pub duplicates: OracleDuplicateBehavior,

    /// The number of times to roll.
    #[serde(rename = "number_of_rolls")]
    pub numberOfRolls: i16,

    #[serde(rename = "oracle")]
    pub oracle: OracleRollableId,
}

/// Provides string templates that may be used in place of the static
/// row text from `OracleTableRow#text`, `OracleTableRow#text2`, and
/// `OracleTableRow#text3`.
/// 
///   These strings are formatted in Markdown, but use a special syntax for
/// their placeholders: `{{text:some_oracle_table_id}}`. The placeholder should
/// be replaced with the value of a rolled (or selected) `OracleTableRow#text`
/// from the target oracle table ID.
#[derive(Serialize, Deserialize)]
pub struct OracleRollTemplate {
    /// A string template that may be used in place of OracleTableRow#text.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<TemplateString>>,

    /// A string template that may be used in place of OracleTableRow#text2.
    #[serde(rename = "text2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text2: Option<Box<TemplateString>>,

    /// A string template that may be used in place of OracleTableRow#text3.
    #[serde(rename = "text3")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text3: Option<Box<TemplateString>>,
}

/// A unique ID for an OracleRollable.
pub type OracleRollableId = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "oracle_type")]
pub enum OracleTableRollable {
    #[serde(rename = "table_text")]
    TableText(OracleTableRollableTableText),

    #[serde(rename = "table_text2")]
    TableText2(OracleTableRollableTableText2),

    #[serde(rename = "table_text3")]
    TableText3(OracleTableRollableTableText3),
}

/// The label at the head of each table column. The `roll` key refers to the
/// roll column showing the dice range (`min` and `max` on each table row).
#[derive(Serialize, Deserialize)]
pub struct OracleTableRollableTableTextColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,

    #[serde(rename = "text")]
    pub text: Label,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableRollableTableTextRecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

/// Represents a basic rollable oracle table with one roll column and one text
/// result column.
#[derive(Serialize, Deserialize)]
pub struct OracleTableRollableTableText {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: OracleRollableId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// The label at the head of each table column. The `roll` key refers to the
    /// roll column showing the dice range (`min` and `max` on each table row).
    #[serde(rename = "column_labels")]
    pub columnLabels: OracleTableRollableTableTextColumnLabels,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleTableRowText>,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A longer description of the oracle table's intended usage, which might
    /// include multiple paragraphs. If it's only a couple sentences, use the
    /// `summary` key instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// An icon that represents this table.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<OracleTableRollableTableTextRecommendedRolls>>,

    /// Indicates that this object replaces the identified OracleRollable.
    /// References to the replaced object can be considered equivalent to this
    /// object.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<OracleRollableId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of the oracle table's intended usage, no more than a few
    /// sentences in length. This is intended for use in application tooltips
    /// and similar sorts of hints. Longer text should use the "description"
    /// key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

/// The label at the head of each table column. The `roll` key refers to the
/// roll column showing the dice range (`min` and `max` on each table row).
#[derive(Serialize, Deserialize)]
pub struct OracleTableRollableTableText2ColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,

    #[serde(rename = "text")]
    pub text: Label,

    #[serde(rename = "text2")]
    pub text2: Label,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableRollableTableText2RecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

/// A rollable oracle table with one roll column and two text columns.
#[derive(Serialize, Deserialize)]
pub struct OracleTableRollableTableText2 {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: OracleRollableId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// The label at the head of each table column. The `roll` key refers to the
    /// roll column showing the dice range (`min` and `max` on each table row).
    #[serde(rename = "column_labels")]
    pub columnLabels: OracleTableRollableTableText2ColumnLabels,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleTableRowText2>,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A longer description of the oracle table's intended usage, which might
    /// include multiple paragraphs. If it's only a couple sentences, use the
    /// `summary` key instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// An icon that represents this table.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<OracleTableRollableTableText2RecommendedRolls>>,

    /// Indicates that this object replaces the identified OracleRollable.
    /// References to the replaced object can be considered equivalent to this
    /// object.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<OracleRollableId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of the oracle table's intended usage, no more than a few
    /// sentences in length. This is intended for use in application tooltips
    /// and similar sorts of hints. Longer text should use the "description"
    /// key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

/// The label at the head of each table column. The `roll` key refers to the
/// roll column showing the dice range (`min` and `max` on each table row).
#[derive(Serialize, Deserialize)]
pub struct OracleTableRollableTableText3ColumnLabels {
    #[serde(rename = "roll")]
    pub roll: Label,

    #[serde(rename = "text")]
    pub text: Label,

    #[serde(rename = "text2")]
    pub text2: Label,

    #[serde(rename = "text3")]
    pub text3: Label,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableRollableTableText3RecommendedRolls {
    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,
}

/// A rollable oracle table with one roll column and 3 text columns.
#[derive(Serialize, Deserialize)]
pub struct OracleTableRollableTableText3 {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: OracleRollableId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// The label at the head of each table column. The `roll` key refers to the
    /// roll column showing the dice range (`min` and `max` on each table row).
    #[serde(rename = "column_labels")]
    pub columnLabels: OracleTableRollableTableText3ColumnLabels,

    /// The roll used to select a result on this oracle.
    #[serde(rename = "dice")]
    pub dice: DiceExpression,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// An array of objects, each representing a single row of the table.
    #[serde(rename = "rows")]
    pub rows: Vec<OracleTableRowText3>,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A longer description of the oracle table's intended usage, which might
    /// include multiple paragraphs. If it's only a couple sentences, use the
    /// `summary` key instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// An icon that represents this table.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Most oracle tables are insensitive to matches, but a few define special
    /// match behavior.
    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleMatchBehavior>>,

    #[serde(rename = "recommended_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recommendedRolls: Option<Box<OracleTableRollableTableText3RecommendedRolls>>,

    /// Indicates that this object replaces the identified OracleRollable.
    /// References to the replaced object can be considered equivalent to this
    /// object.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<OracleRollableId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of the oracle table's intended usage, no more than a few
    /// sentences in length. This is intended for use in application tooltips
    /// and similar sorts of hints. Longer text should use the "description"
    /// key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

/// Represents a row in an oracle table, with a single text cell.
#[derive(Serialize, Deserialize)]
pub struct OracleTableRowText {
    /// High end of the dice range for this table row.
    #[serde(rename = "max")]
    pub max: i16,

    /// Low end of the dice range for this table row.
    #[serde(rename = "min")]
    pub min: i16,

    /// The primary text content of this row.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "_i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleRollableId>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "oracle_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracleRolls: Option<Box<Vec<OracleRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// Represents a row in an oracle table that provides a secondary text field.
#[derive(Serialize, Deserialize)]
pub struct OracleTableRowText2 {
    /// High end of the dice range for this table row.
    #[serde(rename = "max")]
    pub max: i16,

    /// Low end of the dice range for this table row.
    #[serde(rename = "min")]
    pub min: i16,

    /// The primary text content of this row.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "text2")]
    pub text2: MarkdownString,

    #[serde(rename = "_i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleRollableId>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "oracle_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracleRolls: Option<Box<Vec<OracleRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// Represents a row in an oracle table with 3 text cells.
#[derive(Serialize, Deserialize)]
pub struct OracleTableRowText3 {
    /// High end of the dice range for this table row.
    #[serde(rename = "max")]
    pub max: i16,

    /// Low end of the dice range for this table row.
    #[serde(rename = "min")]
    pub min: i16,

    /// The primary text content of this row.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "text2")]
    pub text2: MarkdownString,

    #[serde(rename = "text3")]
    pub text3: MarkdownString,

    #[serde(rename = "_i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleRollableId>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "oracle_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracleRolls: Option<Box<Vec<OracleRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// A grouping of separate tables.
#[derive(Serialize, Deserialize)]
pub enum OracleTablesCollectionOracleType {
    #[serde(rename = "tables")]
    Tables,
}

/// An OracleCollection that represents a category or grouping of tables, which
/// may themselves be `OracleTablesCollection`s.
#[derive(Serialize, Deserialize)]
pub struct OracleTablesCollection {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: OracleCollectionId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// A grouping of separate tables.
    #[serde(rename = "oracle_type")]
    pub oracleType: OracleTablesCollectionOracleType,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "collections")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub collections: Option<Box<HashMap<String, OracleCollection>>>,

    /// A thematic color associated with this collection.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<CssColor>>,

    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<Box<HashMap<String, OracleTableRollable>>>,

    /// A longer description of this collection, which might include multiple
    /// paragraphs. If it's only a couple sentences, use the `summary` key
    /// instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This collection's content enhances the identified collection, rather
    /// than being a standalone collection of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<OracleCollectionId>>,

    /// An SVG icon associated with this collection.
    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpImageUrl>>>,

    /// This collection replaces the identified collection. References to the
    /// replaced collection can be considered equivalent to this collection.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<OracleCollectionId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of this collection, no more than a few sentences in
    /// length. This is intended for use in application tooltips and similar
    /// sorts of hints. Longer text should use the "description" key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

#[derive(Serialize, Deserialize)]
pub enum PartOfSpeech {
    /// An adjective.
    #[serde(rename = "adjective")]
    Adjective,

    /// An adjective used as a proper noun.
    #[serde(rename = "adjective_as_proper_noun")]
    AdjectiveAsProperNoun,

    /// A common noun used as an adjective, to modify another noun.
    #[serde(rename = "adjunct_common_noun")]
    AdjunctCommonNoun,

    /// A proper noun used as an adjective, to modify another noun.
    #[serde(rename = "adjunct_proper_noun")]
    AdjunctProperNoun,

    /// A verb used as an adjective, to modify a noun.
    #[serde(rename = "attributive_verb")]
    AttributiveVerb,

    /// A common noun.
    #[serde(rename = "common_noun")]
    CommonNoun,

    /// An common noun used as a proper noun.
    #[serde(rename = "common_noun_as_proper_noun")]
    CommonNounAsProperNoun,

    /// Gerund or present participle of a verb, e.g. "going", "seeing",
    /// "waving". Can function as a noun, an adjective, or a progressive verb.
    #[serde(rename = "gerund")]
    Gerund,

    /// A proper noun.
    #[serde(rename = "proper_noun")]
    ProperNoun,

    /// A verb in present tense
    #[serde(rename = "verb")]
    Verb,
}

#[derive(Serialize, Deserialize)]
pub enum ProgressRollMethod {
    /// An automatic miss.
    #[serde(rename = "miss")]
    Miss,

    /// Make a progress roll on a progress track associated with this move.
    #[serde(rename = "progress_roll")]
    ProgressRoll,

    /// An automatic strong hit.
    #[serde(rename = "strong_hit")]
    StrongHit,

    /// An automatic weak hit.
    #[serde(rename = "weak_hit")]
    WeakHit,
}

#[derive(Serialize, Deserialize)]
pub enum ProgressRollOptionUsing {
    #[serde(rename = "progress_track")]
    ProgressTrack,
}

#[derive(Serialize, Deserialize)]
pub struct ProgressRollOption {
    #[serde(rename = "using")]
    pub using: ProgressRollOptionUsing,
}

/// Describes the features of a type of progress track.
#[derive(Serialize, Deserialize)]
pub struct ProgressTrackTypeInfo {
    /// A category label for progress tracks of this type.
    #[serde(rename = "category")]
    pub category: Label,

    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, Option<Value>>>>,
}

/// A rarity, as described in Ironsworn: Delve.
#[derive(Serialize, Deserialize)]
pub struct Rarity {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: RarityId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// The asset augmented by this rarity.
    #[serde(rename = "asset")]
    pub asset: AssetId,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    /// From Ironsworn: Delve, p. 174:
    /// 
    ///       Some assets will bring a rarity into play more often than others,
    /// so the experience point cost for a rarity will vary by the linked asset.
    /// These costs are shown in the tables on page 175.
    /// 
    ///       If you are playing solo, and arent concerned with the relative
    /// balance of rarity abilities, you can ignore these variable costs. If so,
    /// spend 3 experience points to purchase a rarity.
    #[serde(rename = "xp_cost")]
    pub xpCost: i16,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,
}

/// A unique ID for a Rarity.
pub type RarityId = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "using")]
pub enum RollableValue {
    #[serde(rename = "asset_control")]
    AssetControl(RollableValueAssetControl),

    #[serde(rename = "asset_option")]
    AssetOption(RollableValueAssetOption),

    #[serde(rename = "attached_asset_control")]
    AttachedAssetControl(RollableValueAttachedAssetControl),

    #[serde(rename = "attached_asset_option")]
    AttachedAssetOption(RollableValueAttachedAssetOption),

    #[serde(rename = "condition_meter")]
    ConditionMeter(RollableValueConditionMeter),

    #[serde(rename = "custom")]
    Custom(RollableValueCustom),

    #[serde(rename = "stat")]
    Stat(RollableValueStat),
}

/// A reference to the value of an asset control.
#[derive(Serialize, Deserialize)]
pub struct RollableValueAssetControl {
    #[serde(rename = "assets")]
    pub assets: Vec<AssetIdWildcard>,

    /// The dictionary key of the asset control field.
    #[serde(rename = "control")]
    pub control: DictKey,
}

/// A reference to the value of an asset option.
#[derive(Serialize, Deserialize)]
pub struct RollableValueAssetOption {
    #[serde(rename = "assets")]
    pub assets: Vec<AssetIdWildcard>,

    /// The dictionary key of the asset option field.
    #[serde(rename = "option")]
    pub option: DictKey,
}

/// A reference to the value of an attached asset control. For example, a Module
/// asset could use this to roll using the `integrity` control of an attached
/// Vehicle.
#[derive(Serialize, Deserialize)]
pub struct RollableValueAttachedAssetControl {
    /// The dictionary key of the asset control field.
    #[serde(rename = "control")]
    pub control: DictKey,
}

/// A reference to the value of an attached asset option.
#[derive(Serialize, Deserialize)]
pub struct RollableValueAttachedAssetOption {
    /// The dictionary key of the asset option field.
    #[serde(rename = "option")]
    pub option: DictKey,
}

/// A reference to the value of a standard player condition meter.
#[derive(Serialize, Deserialize)]
pub struct RollableValueConditionMeter {
    #[serde(rename = "condition_meter")]
    pub conditionMeter: ConditionMeterKey,
}

/// An arbitrary static integer value with a label.
#[derive(Serialize, Deserialize)]
pub struct RollableValueCustom {
    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "value")]
    pub value: i16,
}

/// A reference to the value of a standard player character stat.
#[derive(Serialize, Deserialize)]
pub struct RollableValueStat {
    #[serde(rename = "stat")]
    pub stat: StatKey,
}

/// Describes rules for player characters in this ruleset, such as stats and
/// condition meters.
#[derive(Serialize, Deserialize)]
pub struct Rules {
    /// Describes the standard condition meters used by player characters in
    /// this ruleset.
    #[serde(rename = "condition_meters")]
    pub conditionMeters: HashMap<String, ConditionMeterRule>,

    /// Describes the standard impacts/debilities used by player characters in
    /// this ruleset.
    #[serde(rename = "impacts")]
    pub impacts: HashMap<String, ImpactCategory>,

    /// Describes the special tracks used by player characters in this
    /// ruleset, like Bonds (classic Ironsworn), Failure (Delve), or Legacies
    /// (Starforged).
    #[serde(rename = "special_tracks")]
    pub specialTracks: HashMap<String, SpecialTrackRule>,

    /// Describes the standard stats used by player characters in this ruleset.
    #[serde(rename = "stats")]
    pub stats: HashMap<String, StatRule>,

    #[serde(rename = "tags")]
    pub tags: HashMap<String, TagRule>,
}

/// Describes rules for player characters in this ruleset, such as stats and
/// condition meters.
#[derive(Serialize, Deserialize)]
pub struct RulesExpansion {
    /// Describes the standard condition meters used by player characters in
    /// this ruleset.
    #[serde(rename = "condition_meters")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conditionMeters: Option<Box<HashMap<String, ConditionMeterRule>>>,

    /// Describes the standard impacts/debilities used by player characters in
    /// this ruleset.
    #[serde(rename = "impacts")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub impacts: Option<Box<HashMap<String, ImpactCategory>>>,

    /// Describes the special tracks used by player characters in this
    /// ruleset, like Bonds (classic Ironsworn), Failure (Delve), or Legacies
    /// (Starforged).
    #[serde(rename = "special_tracks")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub specialTracks: Option<Box<HashMap<String, SpecialTrackRule>>>,

    /// Describes the standard stats used by player characters in this ruleset.
    #[serde(rename = "stats")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stats: Option<Box<HashMap<String, StatRule>>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, TagRule>>>,
}

/// The ID of standalone Datasworn package that describes its own ruleset.
pub type RulesetId = String;

#[derive(Serialize, Deserialize)]
pub enum SelectEnhancementFieldChoiceChoiceType {
    #[serde(rename = "choice")]
    Choice,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct SelectEnhancementFieldChoice {
    #[serde(rename = "choice_type")]
    pub choiceType: SelectEnhancementFieldChoiceChoiceType,

    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "enhance_asset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceAsset: Option<Box<AssetEnhancement>>,

    #[serde(rename = "enhance_moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceMoves: Option<Box<Vec<MoveEnhancement>>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "using")]
pub enum SelectValueFieldChoice {
    #[serde(rename = "asset_control")]
    AssetControl(SelectValueFieldChoiceAssetControl),

    #[serde(rename = "asset_option")]
    AssetOption(SelectValueFieldChoiceAssetOption),

    #[serde(rename = "attached_asset_control")]
    AttachedAssetControl(SelectValueFieldChoiceAttachedAssetControl),

    #[serde(rename = "attached_asset_option")]
    AttachedAssetOption(SelectValueFieldChoiceAttachedAssetOption),

    #[serde(rename = "condition_meter")]
    ConditionMeter(SelectValueFieldChoiceConditionMeter),

    #[serde(rename = "custom")]
    Custom(SelectValueFieldChoiceCustom),

    #[serde(rename = "stat")]
    Stat(SelectValueFieldChoiceStat),
}

#[derive(Serialize, Deserialize)]
pub enum SelectValueFieldChoiceAssetControlChoiceType {
    #[serde(rename = "choice")]
    Choice,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct SelectValueFieldChoiceAssetControl {
    #[serde(rename = "assets")]
    pub assets: Vec<AssetIdWildcard>,

    #[serde(rename = "choice_type")]
    pub choiceType: SelectValueFieldChoiceAssetControlChoiceType,

    /// The dictionary key of the asset control field.
    #[serde(rename = "control")]
    pub control: DictKey,

    #[serde(rename = "label")]
    pub label: InputLabel,
}

#[derive(Serialize, Deserialize)]
pub enum SelectValueFieldChoiceAssetOptionChoiceType {
    #[serde(rename = "choice")]
    Choice,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct SelectValueFieldChoiceAssetOption {
    #[serde(rename = "assets")]
    pub assets: Vec<AssetIdWildcard>,

    #[serde(rename = "choice_type")]
    pub choiceType: SelectValueFieldChoiceAssetOptionChoiceType,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// The dictionary key of the asset option field.
    #[serde(rename = "option")]
    pub option: DictKey,
}

#[derive(Serialize, Deserialize)]
pub enum SelectValueFieldChoiceAttachedAssetControlChoiceType {
    #[serde(rename = "choice")]
    Choice,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct SelectValueFieldChoiceAttachedAssetControl {
    #[serde(rename = "choice_type")]
    pub choiceType: SelectValueFieldChoiceAttachedAssetControlChoiceType,

    /// The dictionary key of the asset control field.
    #[serde(rename = "control")]
    pub control: DictKey,

    #[serde(rename = "label")]
    pub label: InputLabel,
}

#[derive(Serialize, Deserialize)]
pub enum SelectValueFieldChoiceAttachedAssetOptionChoiceType {
    #[serde(rename = "choice")]
    Choice,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct SelectValueFieldChoiceAttachedAssetOption {
    #[serde(rename = "choice_type")]
    pub choiceType: SelectValueFieldChoiceAttachedAssetOptionChoiceType,

    #[serde(rename = "label")]
    pub label: InputLabel,

    /// The dictionary key of the asset option field.
    #[serde(rename = "option")]
    pub option: DictKey,
}

#[derive(Serialize, Deserialize)]
pub enum SelectValueFieldChoiceConditionMeterChoiceType {
    #[serde(rename = "choice")]
    Choice,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct SelectValueFieldChoiceConditionMeter {
    #[serde(rename = "choice_type")]
    pub choiceType: SelectValueFieldChoiceConditionMeterChoiceType,

    #[serde(rename = "condition_meter")]
    pub conditionMeter: ConditionMeterKey,

    #[serde(rename = "label")]
    pub label: InputLabel,
}

#[derive(Serialize, Deserialize)]
pub enum SelectValueFieldChoiceCustomChoiceType {
    #[serde(rename = "choice")]
    Choice,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct SelectValueFieldChoiceCustom {
    #[serde(rename = "choice_type")]
    pub choiceType: SelectValueFieldChoiceCustomChoiceType,

    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "value")]
    pub value: i16,
}

#[derive(Serialize, Deserialize)]
pub enum SelectValueFieldChoiceStatChoiceType {
    #[serde(rename = "choice")]
    Choice,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct SelectValueFieldChoiceStat {
    #[serde(rename = "choice_type")]
    pub choiceType: SelectValueFieldChoiceStatChoiceType,

    #[serde(rename = "label")]
    pub label: InputLabel,

    #[serde(rename = "stat")]
    pub stat: StatKey,
}

pub type SemanticVersion = String;

/// Metadata describing the original source of this item
#[derive(Serialize, Deserialize)]
pub struct SourceInfo {
    /// Lists authors credited by the source material.
    #[serde(rename = "authors")]
    pub authors: Vec<AuthorInfo>,

    /// The date of the source documents's last update, formatted YYYY-MM-DD.
    /// Required because it's used to determine whether the data needs updating.
    #[serde(rename = "date")]
    pub date: DateTime<FixedOffset>,

    #[serde(rename = "license")]
    pub license: License,

    /// The title of the source document.
    #[serde(rename = "title")]
    pub title: String,

    /// A URL where the source document is available.
    #[serde(rename = "url")]
    pub url: WebUrl,

    /// The page number where this item is described in full.
    #[serde(rename = "page")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page: Option<Box<u16>>,
}

#[derive(Serialize, Deserialize)]
pub enum SpecialTrackRollMethod {
    /// Use _every_ roll option at once.
    #[serde(rename = "all")]
    All,

    /// Use the roll option with the best/highest value.
    #[serde(rename = "highest")]
    Highest,

    /// Use the roll option with the worst/lowest value.
    #[serde(rename = "lowest")]
    Lowest,

    /// An automatic miss.
    #[serde(rename = "miss")]
    Miss,

    /// The player chooses which roll option to use.
    #[serde(rename = "player_choice")]
    PlayerChoice,

    /// An automatic strong hit.
    #[serde(rename = "strong_hit")]
    StrongHit,

    /// An automatic weak hit.
    #[serde(rename = "weak_hit")]
    WeakHit,
}

/// Describes a special track like Bonds (classic Ironsworn), Failure (Delve),
/// or Legacies (Starforged).
#[derive(Serialize, Deserialize)]
pub struct SpecialTrackRule {
    /// A description of this special track.
    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// A label for this special track.
    #[serde(rename = "label")]
    pub label: InputLabel,

    /// Is this track an optional rule?
    #[serde(rename = "optional")]
    pub optional: bool,

    /// Is this track shared by all players?
    #[serde(rename = "shared")]
    pub shared: bool,
}

/// Special, ruleset-specific progress tracks. Usually, one exists per player
/// character, and they persist through the life of the player character.
/// 'Canonical' examples:
///   * `bonds_track`, described in the Ironsworn Rulebook. For the Starforged
/// legacy track, use `bonds_legacy` instead.
///   * `failure_track`, described in Ironsworn: Delve
///   * `quests_legacy`, `bonds_legacy`, and `discoveries_legacy`, described
/// Ironsworn: Starforged
/// 
pub type SpecialTrackType = DictKey;

/// A basic player character stat.
pub type StatKey = DictKey;

/// Describes a standard player character stat.
#[derive(Serialize, Deserialize)]
pub struct StatRule {
    /// A description of this stat.
    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// A label for this stat.
    #[serde(rename = "label")]
    pub label: InputLabel,
}

#[derive(Serialize, Deserialize)]
pub struct Suggestions {
    #[serde(rename = "assets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assets: Option<Box<Vec<AssetId>>>,

    #[serde(rename = "atlas")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub atlas: Option<Box<Vec<AtlasEntryId>>>,

    #[serde(rename = "moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moves: Option<Box<Vec<MoveId>>>,

    #[serde(rename = "npcs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub npcs: Option<Box<Vec<NpcId>>>,

    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<Vec<OracleRollableId>>>,

    #[serde(rename = "rarities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rarities: Option<Box<Vec<RarityId>>>,

    #[serde(rename = "site_domains")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteDomains: Option<Box<Vec<DelveSiteDomainId>>>,

    #[serde(rename = "site_themes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteThemes: Option<Box<Vec<DelveSiteThemeId>>>,
}

/// A relative (local) URL pointing to a vector image in the SVG format.
pub type SvgImageUrl = String;

pub type Tag = Option<Value>;

#[derive(Serialize, Deserialize)]
#[serde(tag = "value_type")]
pub enum TagRule {
    #[serde(rename = "asset")]
    Asset(TagRuleAsset),

    #[serde(rename = "asset_collection")]
    AssetCollection(TagRuleAssetCollection),

    #[serde(rename = "atlas")]
    Atlas(TagRuleAtlas),

    #[serde(rename = "atlas_entry")]
    AtlasEntry(TagRuleAtlasEntry),

    #[serde(rename = "boolean")]
    Boolean(TagRuleBoolean),

    #[serde(rename = "delve_site")]
    DelveSite(TagRuleDelveSite),

    #[serde(rename = "delve_site_domain")]
    DelveSiteDomain(TagRuleDelveSiteDomain),

    #[serde(rename = "delve_site_theme")]
    DelveSiteTheme(TagRuleDelveSiteTheme),

    #[serde(rename = "enum")]
    Enum(TagRuleEnum),

    #[serde(rename = "integer")]
    Integer(TagRuleInteger),

    #[serde(rename = "move")]
    Move(TagRuleMove),

    #[serde(rename = "move_category")]
    MoveCategory(TagRuleMoveCategory),

    #[serde(rename = "npc")]
    Npc(TagRuleNpc),

    #[serde(rename = "npc_collection")]
    NpcCollection(TagRuleNpcCollection),

    #[serde(rename = "oracle_collection")]
    OracleCollection(TagRuleOracleCollection),

    #[serde(rename = "oracle_rollable")]
    OracleRollable(TagRuleOracleRollable),

    #[serde(rename = "rarity")]
    Rarity(TagRuleRarity),

    #[serde(rename = "truth")]
    Truth(TagRuleTruth),
}

#[derive(Serialize, Deserialize)]
pub struct TagRuleAsset {
    #[serde(rename = "applies_to")]
    pub appliesTo: Vec<ObjectType>,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// If `true`, this field accepts an array of wildcard IDs. If `false`, this
    /// field accepts a single non-wildcard ID.
    #[serde(rename = "wildcard")]
    pub wildcard: bool,
}

#[derive(Serialize, Deserialize)]
pub struct TagRuleAssetCollection {
    #[serde(rename = "applies_to")]
    pub appliesTo: Vec<ObjectType>,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// If `true`, this field accepts an array of wildcard IDs. If `false`, this
    /// field accepts a single non-wildcard ID.
    #[serde(rename = "wildcard")]
    pub wildcard: bool,
}

#[derive(Serialize, Deserialize)]
pub struct TagRuleAtlas {
    #[serde(rename = "applies_to")]
    pub appliesTo: Vec<ObjectType>,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// If `true`, this field accepts an array of wildcard IDs. If `false`, this
    /// field accepts a single non-wildcard ID.
    #[serde(rename = "wildcard")]
    pub wildcard: bool,
}

#[derive(Serialize, Deserialize)]
pub struct TagRuleAtlasEntry {
    #[serde(rename = "applies_to")]
    pub appliesTo: Vec<ObjectType>,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// If `true`, this field accepts an array of wildcard IDs. If `false`, this
    /// field accepts a single non-wildcard ID.
    #[serde(rename = "wildcard")]
    pub wildcard: bool,
}

#[derive(Serialize, Deserialize)]
pub struct TagRuleBoolean {
    #[serde(rename = "applies_to")]
    pub appliesTo: Vec<ObjectType>,

    #[serde(rename = "array")]
    pub array: bool,

    #[serde(rename = "description")]
    pub description: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct TagRuleDelveSite {
    #[serde(rename = "applies_to")]
    pub appliesTo: Vec<ObjectType>,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// If `true`, this field accepts an array of wildcard IDs. If `false`, this
    /// field accepts a single non-wildcard ID.
    #[serde(rename = "wildcard")]
    pub wildcard: bool,
}

#[derive(Serialize, Deserialize)]
pub struct TagRuleDelveSiteDomain {
    #[serde(rename = "applies_to")]
    pub appliesTo: Vec<ObjectType>,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// If `true`, this field accepts an array of wildcard IDs. If `false`, this
    /// field accepts a single non-wildcard ID.
    #[serde(rename = "wildcard")]
    pub wildcard: bool,
}

#[derive(Serialize, Deserialize)]
pub struct TagRuleDelveSiteTheme {
    #[serde(rename = "applies_to")]
    pub appliesTo: Vec<ObjectType>,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// If `true`, this field accepts an array of wildcard IDs. If `false`, this
    /// field accepts a single non-wildcard ID.
    #[serde(rename = "wildcard")]
    pub wildcard: bool,
}

#[derive(Serialize, Deserialize)]
pub struct TagRuleEnum {
    #[serde(rename = "applies_to")]
    pub appliesTo: Vec<ObjectType>,

    #[serde(rename = "array")]
    pub array: bool,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "enum")]
    pub enum_: Vec<DictKey>,
}

#[derive(Serialize, Deserialize)]
pub struct TagRuleInteger {
    #[serde(rename = "applies_to")]
    pub appliesTo: Vec<ObjectType>,

    #[serde(rename = "array")]
    pub array: bool,

    #[serde(rename = "description")]
    pub description: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct TagRuleMove {
    #[serde(rename = "applies_to")]
    pub appliesTo: Vec<ObjectType>,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// If `true`, this field accepts an array of wildcard IDs. If `false`, this
    /// field accepts a single non-wildcard ID.
    #[serde(rename = "wildcard")]
    pub wildcard: bool,
}

#[derive(Serialize, Deserialize)]
pub struct TagRuleMoveCategory {
    #[serde(rename = "applies_to")]
    pub appliesTo: Vec<ObjectType>,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// If `true`, this field accepts an array of wildcard IDs. If `false`, this
    /// field accepts a single non-wildcard ID.
    #[serde(rename = "wildcard")]
    pub wildcard: bool,
}

#[derive(Serialize, Deserialize)]
pub struct TagRuleNpc {
    #[serde(rename = "applies_to")]
    pub appliesTo: Vec<ObjectType>,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// If `true`, this field accepts an array of wildcard IDs. If `false`, this
    /// field accepts a single non-wildcard ID.
    #[serde(rename = "wildcard")]
    pub wildcard: bool,
}

#[derive(Serialize, Deserialize)]
pub struct TagRuleNpcCollection {
    #[serde(rename = "applies_to")]
    pub appliesTo: Vec<ObjectType>,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// If `true`, this field accepts an array of wildcard IDs. If `false`, this
    /// field accepts a single non-wildcard ID.
    #[serde(rename = "wildcard")]
    pub wildcard: bool,
}

#[derive(Serialize, Deserialize)]
pub struct TagRuleOracleCollection {
    #[serde(rename = "applies_to")]
    pub appliesTo: Vec<ObjectType>,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// If `true`, this field accepts an array of wildcard IDs. If `false`, this
    /// field accepts a single non-wildcard ID.
    #[serde(rename = "wildcard")]
    pub wildcard: bool,
}

#[derive(Serialize, Deserialize)]
pub struct TagRuleOracleRollable {
    #[serde(rename = "applies_to")]
    pub appliesTo: Vec<ObjectType>,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// If `true`, this field accepts an array of wildcard IDs. If `false`, this
    /// field accepts a single non-wildcard ID.
    #[serde(rename = "wildcard")]
    pub wildcard: bool,
}

#[derive(Serialize, Deserialize)]
pub struct TagRuleRarity {
    #[serde(rename = "applies_to")]
    pub appliesTo: Vec<ObjectType>,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// If `true`, this field accepts an array of wildcard IDs. If `false`, this
    /// field accepts a single non-wildcard ID.
    #[serde(rename = "wildcard")]
    pub wildcard: bool,
}

#[derive(Serialize, Deserialize)]
pub struct TagRuleTruth {
    #[serde(rename = "applies_to")]
    pub appliesTo: Vec<ObjectType>,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// If `true`, this field accepts an array of wildcard IDs. If `false`, this
    /// field accepts a single non-wildcard ID.
    #[serde(rename = "wildcard")]
    pub wildcard: bool,
}

/// A rich text string in Markdown with replaced values from oracle roll
/// results.
/// 
/// The custom syntax `{{some_row_key:some_oracle_table_id}}` should be replaced
/// by the `some_row_key` string of a rolled oracle table. This is usually the
/// `result` key, for example `{{result:starforged/oracles/core/action}}`
pub type TemplateString = String;

/// A unique ID for a ThemeDangerRow.
pub type ThemeDangerRowId = String;

/// A unique ID for a ThemeFeatureRow.
pub type ThemeFeatureRowId = String;

/// Describes trigger conditions for a move that makes an action roll.
#[derive(Serialize, Deserialize)]
pub struct TriggerActionRoll {
    /// Specific conditions that qualify for this trigger.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerActionRollCondition>,

    /// A markdown string containing the primary trigger text for this move.
    /// 
    /// Secondary trigger text (for specific stats or uses of an asset ability)
    /// may be described in individual trigger conditions.
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerActionRollCondition {
    #[serde(rename = "method")]
    pub method: ActionRollMethod,

    /// The options available when rolling with this trigger condition.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<RollableValue>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerActionRollConditionEnhancement {
    #[serde(rename = "method")]
    pub method: ActionRollMethod,

    /// The options available when rolling with this trigger condition.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<RollableValue>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

/// Describes changes/additions made to the enhanced move's trigger conditions.
#[derive(Serialize, Deserialize)]
pub struct TriggerActionRollEnhancement {
    /// Trigger conditions added to the enhanced move.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerActionRollConditionEnhancement>,
}

/// Information on who can activate this trigger condition. Usually this is just
/// the player, but some asset abilities can trigger from an ally's move.
#[derive(Serialize, Deserialize)]
pub struct TriggerBy {
    /// Can this trigger be activated by one of the player's allies?
    #[serde(rename = "ally")]
    pub ally: bool,

    /// Can this trigger be activated by the player who owns this?
    #[serde(rename = "player")]
    pub player: bool,
}

/// Describes trigger conditions for a move that makes no rolls.
#[derive(Serialize, Deserialize)]
pub struct TriggerNoRoll {
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerNoRollCondition>,

    /// A markdown string containing the primary trigger text for this move.
    /// 
    /// Secondary trigger text (for specific stats or uses of an asset ability)
    /// may be described in individual trigger conditions.
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerNoRollCondition {
    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

/// Describes changes/additions made to the enhanced move's trigger conditions.
#[derive(Serialize, Deserialize)]
pub struct TriggerNoRollEnhancement {
    /// Trigger conditions added to the enhanced move.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerNoRollCondition>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerProgressRoll {
    /// Specific conditions that qualify for this trigger.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerProgressRollCondition>,

    /// A markdown string containing the primary trigger text for this move.
    /// 
    /// Secondary trigger text (for specific stats or uses of an asset ability)
    /// may be described in individual trigger conditions.
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerProgressRollCondition {
    #[serde(rename = "method")]
    pub method: ProgressRollMethod,

    /// The options available when rolling with this trigger condition.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<ProgressRollOption>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerProgressRollConditionEnhancement {
    #[serde(rename = "method")]
    pub method: ProgressRollMethod,

    /// The options available when rolling with this trigger condition.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<ProgressRollOption>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

/// Describes changes/additions made to the enhanced move's trigger conditions.
#[derive(Serialize, Deserialize)]
pub struct TriggerProgressRollEnhancement {
    /// Trigger conditions added to the enhanced move.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerProgressRollConditionEnhancement>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerSpecialTrack {
    /// Specific conditions that qualify for this trigger.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerSpecialTrackCondition>,

    /// A markdown string containing the primary trigger text for this move.
    /// 
    /// Secondary trigger text (for specific stats or uses of an asset ability)
    /// may be described in individual trigger conditions.
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerSpecialTrackCondition {
    #[serde(rename = "method")]
    pub method: SpecialTrackRollMethod,

    /// The options available when rolling with this trigger condition.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<TriggerSpecialTrackConditionOption>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

/// A progress move that rolls on one or more special tracks, like Bonds
/// (classic Ironsworn), Failure (Delve), or Legacy (Starforged).
#[derive(Serialize, Deserialize)]
pub struct TriggerSpecialTrackConditionEnhancement {
    #[serde(rename = "method")]
    pub method: SpecialTrackRollMethod,

    /// The options available when rolling with this trigger condition.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<TriggerSpecialTrackConditionOption>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerSpecialTrackConditionOption {
    #[serde(rename = "using")]
    pub using: SpecialTrackType,
}

/// Describes changes/additions made to the enhanced move's trigger conditions.
#[derive(Serialize, Deserialize)]
pub struct TriggerSpecialTrackEnhancement {
    /// Trigger conditions added to the enhanced move.
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerSpecialTrackConditionEnhancement>,
}

/// A setting truth category.
#[derive(Serialize, Deserialize)]
pub struct Truth {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: TruthId,

    /// Attribution for the original source (such as a book or website) of this
    /// item, including the author and licensing information.
    #[serde(rename = "_source")]
    pub source: SourceInfo,

    /// The primary name/label for this item.
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "options")]
    pub options: Vec<TruthOption>,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    /// The name of this item as it appears on the page in the book, if it's
    /// different from `name`.
    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "tags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<Box<HashMap<String, HashMap<String, Tag>>>>,

    #[serde(rename = "your_character")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub yourCharacter: Option<Box<MarkdownString>>,
}

/// A unique ID for a Truth.
pub type TruthId = String;

#[derive(Serialize, Deserialize)]
pub struct TruthOption {
    /// The unique Datasworn ID for this item.
    #[serde(rename = "_id")]
    pub id: TruthOptionId,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "quest_starter")]
    pub questStarter: MarkdownString,

    /// Any implementation hints or other developer-facing comments on this
    /// object. These should be omitted when presenting the object for gameplay.
    #[serde(rename = "_comment")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<Box<String>>,

    #[serde(rename = "max")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max: Option<Box<i16>>,

    #[serde(rename = "min")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub min: Option<Box<i16>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub table: Option<Box<Vec<TruthOptionTableRow>>>,
}

/// A unique ID for a TruthOption.
pub type TruthOptionId = String;

/// Represents a row in an oracle table, with a single text cell.
#[derive(Serialize, Deserialize)]
pub struct TruthOptionTableRow {
    /// High end of the dice range for this table row.
    #[serde(rename = "max")]
    pub max: i16,

    /// Low end of the dice range for this table row.
    #[serde(rename = "min")]
    pub min: i16,

    /// The primary text content of this row.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "_i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    /// Hints that the identified table should be rendered inside this table
    /// row.
    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleRollableId>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    /// Further oracle rolls prompted by this table row.
    #[serde(rename = "oracle_rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracleRolls: Option<Box<Vec<OracleRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// An absolute URL pointing to a website.
pub type WebUrl = String;

/// A relative (local) URL pointing to a raster image in the WEBP format.
pub type WebpImageUrl = String;
