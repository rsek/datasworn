# Code generated by jtd-codegen for Python v0.3.1

import re
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from enum import Enum
from typing import Any, Dict, List, Optional, Type, Union, get_args, get_origin


@dataclass
class RulesPackage:
    """
    Describes game rules compatible with the Ironsworn tabletop role-playing
    game by Shawn Tomkin.
    """

    package_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RulesPackage':
        variants: Dict[str, Type[RulesPackage]] = {
            "expansion": RulesPackageExpansion,
            "ruleset": RulesPackageRuleset,
        }

        return variants[data["package_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class RulesPackageExpansion(RulesPackage):
    """
    A Datasworn package that relies on an external package to provide its
    ruleset.
    """

    datasworn_version: 'SemanticVersion'
    """
    The version of the Datasworn format used by this data.
    """

    id: 'ExpansionID'
    ruleset: 'RulesetID'
    assets: 'Optional[Dict[str, AssetCollection]]'
    """
    A dictionary object containing asset collections, which contain assets.
    """

    atlas: 'Optional[Dict[str, Atlas]]'
    """
    A dictionary object containing atlas collections, which contain atlas
    entries.
    """

    authors: 'Optional[List[AuthorInfo]]'
    """
    Lists authors credited by the source material.
    """

    date: 'Optional[datetime]'
    """
    The date of the source documents's last update, formatted YYYY-MM-DD.
    Required because it's used to determine whether the data needs updating.
    """

    delve_sites: 'Optional[Dict[str, DelveSite]]'
    """
    A dictionary object of delve sites, like the premade delve sites presented
    in Ironsworn: Delve
    """

    license: 'Optional[License]'
    moves: 'Optional[Dict[str, MoveCategory]]'
    """
    A dictionary object containing move categories, which contain moves.
    """

    npcs: 'Optional[Dict[str, NpcCollection]]'
    """
    A dictionary object containing NPC collections, which contain NPCs.
    """

    oracles: 'Optional[Dict[str, OracleTablesCollection]]'
    """
    A dictionary object containing oracle collections, which may contain oracle
    tables and/or oracle collections.
    """

    rarities: 'Optional[Dict[str, Rarity]]'
    """
    A dictionary object containing rarities, like those presented in Ironsworn:
    Delve.
    """

    rules: 'Optional[RulesExpansion]'
    site_domains: 'Optional[Dict[str, DelveSiteDomain]]'
    """
    A dictionary object containing delve site domains.
    """

    site_themes: 'Optional[Dict[str, DelveSiteTheme]]'
    """
    A dictionary object containing delve site themes.
    """

    title: 'Optional[str]'
    """
    The title of the source document.
    """

    truths: 'Optional[Dict[str, Truth]]'
    """
    A dictionary object of truth categories.
    """

    url: 'Optional[WebURL]'
    """
    A URL where the source document is available.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'RulesPackageExpansion':
        return cls(
            "expansion",
            _from_json_data(SemanticVersion, data.get("datasworn_version")),
            _from_json_data(ExpansionID, data.get("id")),
            _from_json_data(RulesetID, data.get("ruleset")),
            _from_json_data(Optional[Dict[str, AssetCollection]], data.get("assets")),
            _from_json_data(Optional[Dict[str, Atlas]], data.get("atlas")),
            _from_json_data(Optional[List[AuthorInfo]], data.get("authors")),
            _from_json_data(Optional[datetime], data.get("date")),
            _from_json_data(Optional[Dict[str, DelveSite]], data.get("delve_sites")),
            _from_json_data(Optional[License], data.get("license")),
            _from_json_data(Optional[Dict[str, MoveCategory]], data.get("moves")),
            _from_json_data(Optional[Dict[str, NpcCollection]], data.get("npcs")),
            _from_json_data(Optional[Dict[str, OracleTablesCollection]], data.get("oracles")),
            _from_json_data(Optional[Dict[str, Rarity]], data.get("rarities")),
            _from_json_data(Optional[RulesExpansion], data.get("rules")),
            _from_json_data(Optional[Dict[str, DelveSiteDomain]], data.get("site_domains")),
            _from_json_data(Optional[Dict[str, DelveSiteTheme]], data.get("site_themes")),
            _from_json_data(Optional[str], data.get("title")),
            _from_json_data(Optional[Dict[str, Truth]], data.get("truths")),
            _from_json_data(Optional[WebURL], data.get("url")),
        )

    def to_json_data(self) -> Any:
        data = { "package_type": "expansion" }
        data["datasworn_version"] = _to_json_data(self.datasworn_version)
        data["id"] = _to_json_data(self.id)
        data["ruleset"] = _to_json_data(self.ruleset)
        if self.assets is not None:
             data["assets"] = _to_json_data(self.assets)
        if self.atlas is not None:
             data["atlas"] = _to_json_data(self.atlas)
        if self.authors is not None:
             data["authors"] = _to_json_data(self.authors)
        if self.date is not None:
             data["date"] = _to_json_data(self.date)
        if self.delve_sites is not None:
             data["delve_sites"] = _to_json_data(self.delve_sites)
        if self.license is not None:
             data["license"] = _to_json_data(self.license)
        if self.moves is not None:
             data["moves"] = _to_json_data(self.moves)
        if self.npcs is not None:
             data["npcs"] = _to_json_data(self.npcs)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.rarities is not None:
             data["rarities"] = _to_json_data(self.rarities)
        if self.rules is not None:
             data["rules"] = _to_json_data(self.rules)
        if self.site_domains is not None:
             data["site_domains"] = _to_json_data(self.site_domains)
        if self.site_themes is not None:
             data["site_themes"] = _to_json_data(self.site_themes)
        if self.title is not None:
             data["title"] = _to_json_data(self.title)
        if self.truths is not None:
             data["truths"] = _to_json_data(self.truths)
        if self.url is not None:
             data["url"] = _to_json_data(self.url)
        return data

@dataclass
class RulesPackageRuleset(RulesPackage):
    """
    A standalone Datasworn package that describes its own ruleset.
    """

    assets: 'Dict[str, AssetCollection]'
    """
    A dictionary object containing asset collections, which contain assets.
    """

    authors: 'List[AuthorInfo]'
    """
    Lists authors credited by the source material.
    """

    datasworn_version: 'SemanticVersion'
    """
    The version of the Datasworn format used by this data.
    """

    date: 'datetime'
    """
    The date of the source documents's last update, formatted YYYY-MM-DD.
    Required because it's used to determine whether the data needs updating.
    """

    id: 'RulesetID'
    license: 'License'
    moves: 'Dict[str, MoveCategory]'
    """
    A dictionary object containing move categories, which contain moves.
    """

    oracles: 'Dict[str, OracleTablesCollection]'
    """
    A dictionary object containing oracle collections, which may contain oracle
    tables and/or oracle collections.
    """

    rules: 'Rules'
    title: 'str'
    """
    The title of the source document.
    """

    url: 'WebURL'
    """
    A URL where the source document is available.
    """

    atlas: 'Optional[Dict[str, Atlas]]'
    """
    A dictionary object containing atlas collections, which contain atlas
    entries.
    """

    delve_sites: 'Optional[Dict[str, DelveSite]]'
    """
    A dictionary object of delve sites, like the premade delve sites presented
    in Ironsworn: Delve
    """

    npcs: 'Optional[Dict[str, NpcCollection]]'
    """
    A dictionary object containing NPC collections, which contain NPCs.
    """

    rarities: 'Optional[Dict[str, Rarity]]'
    """
    A dictionary object containing rarities, like those presented in Ironsworn:
    Delve.
    """

    site_domains: 'Optional[Dict[str, DelveSiteDomain]]'
    """
    A dictionary object containing delve site domains.
    """

    site_themes: 'Optional[Dict[str, DelveSiteTheme]]'
    """
    A dictionary object containing delve site themes.
    """

    truths: 'Optional[Dict[str, Truth]]'
    """
    A dictionary object of truth categories.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'RulesPackageRuleset':
        return cls(
            "ruleset",
            _from_json_data(Dict[str, AssetCollection], data.get("assets")),
            _from_json_data(List[AuthorInfo], data.get("authors")),
            _from_json_data(SemanticVersion, data.get("datasworn_version")),
            _from_json_data(datetime, data.get("date")),
            _from_json_data(RulesetID, data.get("id")),
            _from_json_data(License, data.get("license")),
            _from_json_data(Dict[str, MoveCategory], data.get("moves")),
            _from_json_data(Dict[str, OracleTablesCollection], data.get("oracles")),
            _from_json_data(Rules, data.get("rules")),
            _from_json_data(str, data.get("title")),
            _from_json_data(WebURL, data.get("url")),
            _from_json_data(Optional[Dict[str, Atlas]], data.get("atlas")),
            _from_json_data(Optional[Dict[str, DelveSite]], data.get("delve_sites")),
            _from_json_data(Optional[Dict[str, NpcCollection]], data.get("npcs")),
            _from_json_data(Optional[Dict[str, Rarity]], data.get("rarities")),
            _from_json_data(Optional[Dict[str, DelveSiteDomain]], data.get("site_domains")),
            _from_json_data(Optional[Dict[str, DelveSiteTheme]], data.get("site_themes")),
            _from_json_data(Optional[Dict[str, Truth]], data.get("truths")),
        )

    def to_json_data(self) -> Any:
        data = { "package_type": "ruleset" }
        data["assets"] = _to_json_data(self.assets)
        data["authors"] = _to_json_data(self.authors)
        data["datasworn_version"] = _to_json_data(self.datasworn_version)
        data["date"] = _to_json_data(self.date)
        data["id"] = _to_json_data(self.id)
        data["license"] = _to_json_data(self.license)
        data["moves"] = _to_json_data(self.moves)
        data["oracles"] = _to_json_data(self.oracles)
        data["rules"] = _to_json_data(self.rules)
        data["title"] = _to_json_data(self.title)
        data["url"] = _to_json_data(self.url)
        if self.atlas is not None:
             data["atlas"] = _to_json_data(self.atlas)
        if self.delve_sites is not None:
             data["delve_sites"] = _to_json_data(self.delve_sites)
        if self.npcs is not None:
             data["npcs"] = _to_json_data(self.npcs)
        if self.rarities is not None:
             data["rarities"] = _to_json_data(self.rarities)
        if self.site_domains is not None:
             data["site_domains"] = _to_json_data(self.site_domains)
        if self.site_themes is not None:
             data["site_themes"] = _to_json_data(self.site_themes)
        if self.truths is not None:
             data["truths"] = _to_json_data(self.truths)
        return data

class ActionRollMethod(Enum):
    ALL = "all"
    """
    Use _every_ roll option at once.
    """

    HIGHEST = "highest"
    """
    Use the roll option with the best/highest value.
    """

    LOWEST = "lowest"
    """
    Use the roll option with the worst/lowest value.
    """

    MISS = "miss"
    """
    An automatic miss.
    """

    PLAYER_CHOICE = "player_choice"
    """
    The player chooses which roll option to use.
    """

    STRONG_HIT = "strong_hit"
    """
    An automatic strong hit.
    """

    WEAK_HIT = "weak_hit"
    """
    An automatic weak hit.
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'ActionRollMethod':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class Asset:
    abilities: 'List[AssetAbility]'
    category: 'Label'
    """
    A localized category label for this asset. This is the surtitle above the
    asset's name on the card.
    """

    count_as_impact: 'bool'
    """
    If `true`, this asset counts as an impact (Starforged) or a debility
    (classic Ironsworn).
    """

    id: 'AssetID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    shared: 'bool'
    """
    Most assets only benefit to their owner, but certain assets (like
    Starforged's module and command vehicle assets) are shared amongst the
    player's allies, too.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    attachments: 'Optional[AssetAttachment]'
    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this asset.
    """

    controls: 'Optional[Dict[str, AssetControlField]]'
    """
    Controls are condition meters, clocks, counters, and other asset input
    fields whose values are expected to change throughout the life of the asset.
    """

    icon: 'Optional[SvgImageURL]'
    """
    This asset's icon.
    """

    options: 'Optional[Dict[str, AssetOptionField]]'
    """
    Options are input fields set when the player purchases the asset. They're
    likely to remain the same through the life of the asset. Typically, they are
    rendered at the top of the asset card.
    """

    requirement: 'Optional[MarkdownString]'
    """
    Describes prerequisites for purchasing or using this asset.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Asset':
        return cls(
            _from_json_data(List[AssetAbility], data.get("abilities")),
            _from_json_data(Label, data.get("category")),
            _from_json_data(bool, data.get("count_as_impact")),
            _from_json_data(AssetID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(bool, data.get("shared")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(Optional[AssetAttachment], data.get("attachments")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[Dict[str, AssetControlField]], data.get("controls")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[Dict[str, AssetOptionField]], data.get("options")),
            _from_json_data(Optional[MarkdownString], data.get("requirement")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["abilities"] = _to_json_data(self.abilities)
        data["category"] = _to_json_data(self.category)
        data["count_as_impact"] = _to_json_data(self.count_as_impact)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["shared"] = _to_json_data(self.shared)
        data["source"] = _to_json_data(self.source)
        if self.attachments is not None:
             data["attachments"] = _to_json_data(self.attachments)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.controls is not None:
             data["controls"] = _to_json_data(self.controls)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.options is not None:
             data["options"] = _to_json_data(self.options)
        if self.requirement is not None:
             data["requirement"] = _to_json_data(self.requirement)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class AssetAbility:
    """
    An asset ability: one of the purchasable features of an asset. Most assets
    have three.
    """

    enabled: 'bool'
    """
    Is this asset ability enabled?
    """

    id: 'AssetAbilityID'
    """
    The unique Datasworn ID for this item.
    """

    text: 'MarkdownString'
    """
    The complete rules text of this asset ability.
    """

    controls: 'Optional[Dict[str, AssetAbilityControlField]]'
    """
    Fields whose values are expected to change over the life of the asset.
    """

    enhance_asset: 'Optional[AssetEnhancement]'
    """
    Changes made to the asset, when this ability is enabled.
    """

    enhance_moves: 'Optional[List[MoveEnhancement]]'
    """
    Describes changes made to various moves by this asset ability. Usually these
    require specific trigger conditions.
    """

    moves: 'Optional[Dict[str, Move]]'
    """
    Unique moves added by this asset ability.
    """

    name: 'Optional[Label]'
    """
    A handful of asset abilities have a label/name, for instance classic
    Ironsworn companion assets. Most canonical assets omit this property.
    """

    options: 'Optional[Dict[str, AssetAbilityOptionField]]'
    """
    Fields that are expected to be set once and remain the same through the life
    of the asset.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbility':
        return cls(
            _from_json_data(bool, data.get("enabled")),
            _from_json_data(AssetAbilityID, data.get("id")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(Optional[Dict[str, AssetAbilityControlField]], data.get("controls")),
            _from_json_data(Optional[AssetEnhancement], data.get("enhance_asset")),
            _from_json_data(Optional[List[MoveEnhancement]], data.get("enhance_moves")),
            _from_json_data(Optional[Dict[str, Move]], data.get("moves")),
            _from_json_data(Optional[Label], data.get("name")),
            _from_json_data(Optional[Dict[str, AssetAbilityOptionField]], data.get("options")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["enabled"] = _to_json_data(self.enabled)
        data["id"] = _to_json_data(self.id)
        data["text"] = _to_json_data(self.text)
        if self.controls is not None:
             data["controls"] = _to_json_data(self.controls)
        if self.enhance_asset is not None:
             data["enhance_asset"] = _to_json_data(self.enhance_asset)
        if self.enhance_moves is not None:
             data["enhance_moves"] = _to_json_data(self.enhance_moves)
        if self.moves is not None:
             data["moves"] = _to_json_data(self.moves)
        if self.name is not None:
             data["name"] = _to_json_data(self.name)
        if self.options is not None:
             data["options"] = _to_json_data(self.options)
        return data

@dataclass
class AssetAbilityControlField:
    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityControlField':
        variants: Dict[str, Type[AssetAbilityControlField]] = {
            "checkbox": AssetAbilityControlFieldCheckbox,
            "clock": AssetAbilityControlFieldClock,
            "counter": AssetAbilityControlFieldCounter,
            "text": AssetAbilityControlFieldText,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetAbilityControlFieldCheckbox(AssetAbilityControlField):
    disables_asset: 'bool'
    """
    Does this field disable the asset when its value is set to `true`?
    """

    is_impact: 'bool'
    """
    Does this field count as an impact (Starforged) or debility (Ironsworn
    classic) when its value is set to `true`?
    """

    label: 'InputLabel'
    value: 'bool'
    """
    Is the box checked?
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityControlFieldCheckbox':
        return cls(
            "checkbox",
            _from_json_data(bool, data.get("disables_asset")),
            _from_json_data(bool, data.get("is_impact")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(bool, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "checkbox" }
        data["disables_asset"] = _to_json_data(self.disables_asset)
        data["is_impact"] = _to_json_data(self.is_impact)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetAbilityControlFieldClock(AssetAbilityControlField):
    """
    A clock with 4 or more segments.
    """

    label: 'InputLabel'
    max: 'int'
    """
    The size of the clock -- in other words, the maximum number of filled clock
    segments. Standard clocks have 4, 6, 8, or 10 segments.
    """

    min: 'int'
    """
    The minimum number of filled clock segments. This is always 0.
    """

    rollable: 'bool'
    value: 'int'
    """
    The current value of this input.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityControlFieldClock':
        return cls(
            "clock",
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(bool, data.get("rollable")),
            _from_json_data(int, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "clock" }
        data["label"] = _to_json_data(self.label)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["rollable"] = _to_json_data(self.rollable)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetAbilityControlFieldCounter(AssetAbilityControlField):
    """
    A basic counter representing a non-rollable integer value. They usually
    start at 0, and may or may not have a maximum.
    """

    label: 'InputLabel'
    max: 'int'
    min: 'int'
    """
    The (inclusive) minimum value.
    """

    rollable: 'bool'
    value: 'int'
    """
    The current value of this input.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityControlFieldCounter':
        return cls(
            "counter",
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(bool, data.get("rollable")),
            _from_json_data(int, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "counter" }
        data["label"] = _to_json_data(self.label)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["rollable"] = _to_json_data(self.rollable)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetAbilityControlFieldText(AssetAbilityControlField):
    """
    Represents an input that accepts plain text.
    """

    label: 'InputLabel'
    value: 'str'
    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityControlFieldText':
        return cls(
            "text",
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(str, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "text" }
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetAbilityID:
    """
    A unique ID for an AssetAbility.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetAbilityOptionField:
    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityOptionField':
        variants: Dict[str, Type[AssetAbilityOptionField]] = {
            "text": AssetAbilityOptionFieldText,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetAbilityOptionFieldText(AssetAbilityOptionField):
    """
    Represents an input that accepts plain text.
    """

    label: 'InputLabel'
    value: 'str'
    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityOptionFieldText':
        return cls(
            "text",
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(str, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "text" }
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetAttachment:
    """
    Describes which assets can be attached to this asset. Example: Starforged's
    Module assets, which can be equipped by Command Vehicle assets. See p. 55 of
    Starforged for more info.
    """

    assets: 'List[AssetIDWildcard]'
    """
    Asset IDs (which may be wildcards) that may be attached to this asset
    """

    max: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAttachment':
        return cls(
            _from_json_data(List[AssetIDWildcard], data.get("assets")),
            _from_json_data(int, data.get("max")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["assets"] = _to_json_data(self.assets)
        data["max"] = _to_json_data(self.max)
        return data

@dataclass
class AssetCollection:
    id: 'AssetCollectionID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this collection.
    """

    contents: 'Optional[Dict[str, Asset]]'
    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[AssetCollectionID]'
    """
    This collection's content enhances the identified collection, rather than
    being a standalone collection of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[AssetCollectionID]'
    """
    This collection replaces the identified collection. References to the
    replaced collection can be considered equivalent to this collection.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetCollection':
        return cls(
            _from_json_data(AssetCollectionID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[Dict[str, Asset]], data.get("contents")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[AssetCollectionID], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[AssetCollectionID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.contents is not None:
             data["contents"] = _to_json_data(self.contents)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class AssetCollectionID:
    """
    A unique ID for an AssetCollection.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetCollectionID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetConditionMeterControlField:
    """
    A checkbox control field, rendered as part of an asset condition meter.
    """

    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetConditionMeterControlField':
        variants: Dict[str, Type[AssetConditionMeterControlField]] = {
            "card_flip": AssetConditionMeterControlFieldCardFlip,
            "checkbox": AssetConditionMeterControlFieldCheckbox,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetConditionMeterControlFieldCardFlip(AssetConditionMeterControlField):
    disables_asset: 'bool'
    """
    Does this field disable the asset when its value is set to `true`?
    """

    is_impact: 'bool'
    """
    Does this field count as an impact (Starforged) or debility (Ironsworn
    classic) when its value is set to `true`?
    """

    label: 'InputLabel'
    value: 'bool'
    """
    Is the card flipped over?
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetConditionMeterControlFieldCardFlip':
        return cls(
            "card_flip",
            _from_json_data(bool, data.get("disables_asset")),
            _from_json_data(bool, data.get("is_impact")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(bool, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "card_flip" }
        data["disables_asset"] = _to_json_data(self.disables_asset)
        data["is_impact"] = _to_json_data(self.is_impact)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetConditionMeterControlFieldCheckbox(AssetConditionMeterControlField):
    disables_asset: 'bool'
    """
    Does this field disable the asset when its value is set to `true`?
    """

    is_impact: 'bool'
    """
    Does this field count as an impact (Starforged) or debility (Ironsworn
    classic) when its value is set to `true`?
    """

    label: 'InputLabel'
    value: 'bool'
    """
    Is the box checked?
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetConditionMeterControlFieldCheckbox':
        return cls(
            "checkbox",
            _from_json_data(bool, data.get("disables_asset")),
            _from_json_data(bool, data.get("is_impact")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(bool, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "checkbox" }
        data["disables_asset"] = _to_json_data(self.disables_asset)
        data["is_impact"] = _to_json_data(self.is_impact)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetControlField:
    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlField':
        variants: Dict[str, Type[AssetControlField]] = {
            "card_flip": AssetControlFieldCardFlip,
            "checkbox": AssetControlFieldCheckbox,
            "condition_meter": AssetControlFieldConditionMeter,
            "select_enhancement": AssetControlFieldSelectEnhancement,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetControlFieldCardFlip(AssetControlField):
    disables_asset: 'bool'
    """
    Does this field disable the asset when its value is set to `true`?
    """

    is_impact: 'bool'
    """
    Does this field count as an impact (Starforged) or debility (Ironsworn
    classic) when its value is set to `true`?
    """

    label: 'InputLabel'
    value: 'bool'
    """
    Is the card flipped over?
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldCardFlip':
        return cls(
            "card_flip",
            _from_json_data(bool, data.get("disables_asset")),
            _from_json_data(bool, data.get("is_impact")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(bool, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "card_flip" }
        data["disables_asset"] = _to_json_data(self.disables_asset)
        data["is_impact"] = _to_json_data(self.is_impact)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetControlFieldCheckbox(AssetControlField):
    disables_asset: 'bool'
    """
    Does this field disable the asset when its value is set to `true`?
    """

    is_impact: 'bool'
    """
    Does this field count as an impact (Starforged) or debility (Ironsworn
    classic) when its value is set to `true`?
    """

    label: 'InputLabel'
    value: 'bool'
    """
    Is the box checked?
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldCheckbox':
        return cls(
            "checkbox",
            _from_json_data(bool, data.get("disables_asset")),
            _from_json_data(bool, data.get("is_impact")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(bool, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "checkbox" }
        data["disables_asset"] = _to_json_data(self.disables_asset)
        data["is_impact"] = _to_json_data(self.is_impact)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetControlFieldConditionMeterMoves:
    """
    Provides hints for moves that interact with this condition meter, such as
    suffer and recovery moves.
    """

    recover: 'Optional[List[MoveIDWildcard]]'
    """
    The ID(s) of recovery moves associated with this meter.
    """

    suffer: 'Optional[List[MoveIDWildcard]]'
    """
    The ID(s) of suffer moves associated with the condition meter. If the
    suffer move makes an action roll, this condition meter value should be made
    available as a roll option.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldConditionMeterMoves':
        return cls(
            _from_json_data(Optional[List[MoveIDWildcard]], data.get("recover")),
            _from_json_data(Optional[List[MoveIDWildcard]], data.get("suffer")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.recover is not None:
             data["recover"] = _to_json_data(self.recover)
        if self.suffer is not None:
             data["suffer"] = _to_json_data(self.suffer)
        return data

@dataclass
class AssetControlFieldConditionMeter(AssetControlField):
    """
    Some assets provide a special condition meter of their own. The most common
    example is the health meters on companion assets. Asset condition meters
    may also include their own controls, such as the checkboxes that Starforged
    companion assets use to indicate they are "out of action".
    """

    label: 'InputLabel'
    max: 'int'
    """
    The maximum value of this meter.
    """

    min: 'int'
    """
    The minimum value of this meter.
    """

    rollable: 'bool'
    """
    Is this meter's `value` usable as a stat in an action roll?
    """

    value: 'int'
    """
    The current value of this meter.
    """

    controls: 'Optional[Dict[str, AssetConditionMeterControlField]]'
    """
    Checkbox controls rendered as part of the condition meter.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """

    moves: 'Optional[AssetControlFieldConditionMeterMoves]'
    """
    Provides hints for moves that interact with this condition meter, such as
    suffer and recovery moves.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldConditionMeter':
        return cls(
            "condition_meter",
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(bool, data.get("rollable")),
            _from_json_data(int, data.get("value")),
            _from_json_data(Optional[Dict[str, AssetConditionMeterControlField]], data.get("controls")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[AssetControlFieldConditionMeterMoves], data.get("moves")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "condition_meter" }
        data["label"] = _to_json_data(self.label)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["rollable"] = _to_json_data(self.rollable)
        data["value"] = _to_json_data(self.value)
        if self.controls is not None:
             data["controls"] = _to_json_data(self.controls)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.moves is not None:
             data["moves"] = _to_json_data(self.moves)
        return data

@dataclass
class AssetControlFieldSelectEnhancementChoice:
    choice_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldSelectEnhancementChoice':
        variants: Dict[str, Type[AssetControlFieldSelectEnhancementChoice]] = {
            "choice": AssetControlFieldSelectEnhancementChoiceChoice,
            "choice_group": AssetControlFieldSelectEnhancementChoiceChoiceGroup,
        }

        return variants[data["choice_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetControlFieldSelectEnhancementChoiceChoice(AssetControlFieldSelectEnhancementChoice):
    """
    Represents an option in a list of choices.
    """

    label: 'InputLabel'
    enhance_asset: 'Optional[AssetEnhancement]'
    enhance_moves: 'Optional[List[MoveEnhancement]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldSelectEnhancementChoiceChoice':
        return cls(
            "choice",
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(Optional[AssetEnhancement], data.get("enhance_asset")),
            _from_json_data(Optional[List[MoveEnhancement]], data.get("enhance_moves")),
        )

    def to_json_data(self) -> Any:
        data = { "choice_type": "choice" }
        data["label"] = _to_json_data(self.label)
        if self.enhance_asset is not None:
             data["enhance_asset"] = _to_json_data(self.enhance_asset)
        if self.enhance_moves is not None:
             data["enhance_moves"] = _to_json_data(self.enhance_moves)
        return data

@dataclass
class AssetControlFieldSelectEnhancementChoiceChoiceGroup(AssetControlFieldSelectEnhancementChoice):
    """
    Represents a grouping of options in a list of choices.
    """

    choices: 'Dict[str, SelectEnhancementFieldChoice]'
    name: 'InputLabel'
    """
    A label for this option group.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldSelectEnhancementChoiceChoiceGroup':
        return cls(
            "choice_group",
            _from_json_data(Dict[str, SelectEnhancementFieldChoice], data.get("choices")),
            _from_json_data(InputLabel, data.get("name")),
        )

    def to_json_data(self) -> Any:
        data = { "choice_type": "choice_group" }
        data["choices"] = _to_json_data(self.choices)
        data["name"] = _to_json_data(self.name)
        return data

@dataclass
class AssetControlFieldSelectEnhancement(AssetControlField):
    """
    Select from player and/or asset enhancements. Use it to describe modal
    abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
    (Sundered Isles).
    """

    choices: 'Dict[str, AssetControlFieldSelectEnhancementChoice]'
    label: 'InputLabel'
    value: 'DictKey'
    """
    The key of the currently selected choice from the `choices` property, or
    `null` if none is selected.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldSelectEnhancement':
        return cls(
            "select_enhancement",
            _from_json_data(Dict[str, AssetControlFieldSelectEnhancementChoice], data.get("choices")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(DictKey, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "select_enhancement" }
        data["choices"] = _to_json_data(self.choices)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetControlFieldEnhancement:
    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldEnhancement':
        variants: Dict[str, Type[AssetControlFieldEnhancement]] = {
            "condition_meter": AssetControlFieldEnhancementConditionMeter,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetControlFieldEnhancementConditionMeter(AssetControlFieldEnhancement):
    """
    Some assets provide a special condition meter of their own. The most common
    example is the health meters on companion assets. Asset condition meters
    may also include their own controls, such as the checkboxes that Starforged
    companion assets use to indicate they are "out of action".
    """

    max: 'int'
    """
    The maximum value of this meter.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldEnhancementConditionMeter':
        return cls(
            "condition_meter",
            _from_json_data(int, data.get("max")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "condition_meter" }
        data["max"] = _to_json_data(self.max)
        return data

@dataclass
class AssetEnhancement:
    """
    Describes enhancements made to this asset in a partial asset object. The
    changes should be applied recursively; only the values that are specified
    should be changed.
    """

    attachments: 'Optional[AssetAttachment]'
    controls: 'Optional[Dict[str, AssetControlFieldEnhancement]]'
    """
    Controls are condition meters, clocks, counters, and other asset input
    fields whose values are expected to change throughout the life of the asset.
    """

    count_as_impact: 'Optional[bool]'
    """
    If `true`, this asset counts as an impact (Starforged) or a debility
    (classic Ironsworn).
    """

    shared: 'Optional[bool]'
    """
    Most assets only benefit to their owner, but certain assets (like
    Starforged's module and command vehicle assets) are shared amongst the
    player's allies, too.
    """

    suggestions: 'Optional[Suggestions]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetEnhancement':
        return cls(
            _from_json_data(Optional[AssetAttachment], data.get("attachments")),
            _from_json_data(Optional[Dict[str, AssetControlFieldEnhancement]], data.get("controls")),
            _from_json_data(Optional[bool], data.get("count_as_impact")),
            _from_json_data(Optional[bool], data.get("shared")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.attachments is not None:
             data["attachments"] = _to_json_data(self.attachments)
        if self.controls is not None:
             data["controls"] = _to_json_data(self.controls)
        if self.count_as_impact is not None:
             data["count_as_impact"] = _to_json_data(self.count_as_impact)
        if self.shared is not None:
             data["shared"] = _to_json_data(self.shared)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        return data

@dataclass
class AssetID:
    """
    A unique ID for an Asset.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetIDWildcard:
    """
    A wildcarded ID that can be used to match multiple Assets.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetOptionField:
    """
    Options are asset input fields which are set once, usually when the
    character takes the asset. The most common example is the "name" field on
    companion assets. A more complex example is the choice of a god's stat for
    the Devotant asset.
    """

    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionField':
        variants: Dict[str, Type[AssetOptionField]] = {
            "select_enhancement": AssetOptionFieldSelectEnhancement,
            "select_value": AssetOptionFieldSelectValue,
            "text": AssetOptionFieldText,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetOptionFieldSelectEnhancementChoice:
    choice_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectEnhancementChoice':
        variants: Dict[str, Type[AssetOptionFieldSelectEnhancementChoice]] = {
            "choice": AssetOptionFieldSelectEnhancementChoiceChoice,
            "choice_group": AssetOptionFieldSelectEnhancementChoiceChoiceGroup,
        }

        return variants[data["choice_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetOptionFieldSelectEnhancementChoiceChoice(AssetOptionFieldSelectEnhancementChoice):
    """
    Represents an option in a list of choices.
    """

    label: 'InputLabel'
    enhance_asset: 'Optional[AssetEnhancement]'
    enhance_moves: 'Optional[List[MoveEnhancement]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectEnhancementChoiceChoice':
        return cls(
            "choice",
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(Optional[AssetEnhancement], data.get("enhance_asset")),
            _from_json_data(Optional[List[MoveEnhancement]], data.get("enhance_moves")),
        )

    def to_json_data(self) -> Any:
        data = { "choice_type": "choice" }
        data["label"] = _to_json_data(self.label)
        if self.enhance_asset is not None:
             data["enhance_asset"] = _to_json_data(self.enhance_asset)
        if self.enhance_moves is not None:
             data["enhance_moves"] = _to_json_data(self.enhance_moves)
        return data

@dataclass
class AssetOptionFieldSelectEnhancementChoiceChoiceGroup(AssetOptionFieldSelectEnhancementChoice):
    """
    Represents a grouping of options in a list of choices.
    """

    choices: 'Dict[str, SelectEnhancementFieldChoice]'
    name: 'InputLabel'
    """
    A label for this option group.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectEnhancementChoiceChoiceGroup':
        return cls(
            "choice_group",
            _from_json_data(Dict[str, SelectEnhancementFieldChoice], data.get("choices")),
            _from_json_data(InputLabel, data.get("name")),
        )

    def to_json_data(self) -> Any:
        data = { "choice_type": "choice_group" }
        data["choices"] = _to_json_data(self.choices)
        data["name"] = _to_json_data(self.name)
        return data

@dataclass
class AssetOptionFieldSelectEnhancement(AssetOptionField):
    """
    Select from player and/or asset enhancements. Use it to describe modal
    abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
    (Sundered Isles).
    """

    choices: 'Dict[str, AssetOptionFieldSelectEnhancementChoice]'
    label: 'InputLabel'
    value: 'DictKey'
    """
    The key of the currently selected choice from the `choices` property, or
    `null` if none is selected.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectEnhancement':
        return cls(
            "select_enhancement",
            _from_json_data(Dict[str, AssetOptionFieldSelectEnhancementChoice], data.get("choices")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(DictKey, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "select_enhancement" }
        data["choices"] = _to_json_data(self.choices)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetOptionFieldSelectValue(AssetOptionField):
    """
    Represents a list of mutually exclusive choices.
    """

    choices: 'Dict[str, SelectValueFieldChoice]'
    label: 'InputLabel'
    value: 'DictKey'
    """
    The key of the currently selected choice from the `choices` property, or
    `null` if none is selected.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectValue':
        return cls(
            "select_value",
            _from_json_data(Dict[str, SelectValueFieldChoice], data.get("choices")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(DictKey, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "select_value" }
        data["choices"] = _to_json_data(self.choices)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetOptionFieldText(AssetOptionField):
    """
    Represents an input that accepts plain text.
    """

    label: 'InputLabel'
    value: 'str'
    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldText':
        return cls(
            "text",
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(str, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "text" }
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class Atlas:
    id: 'AtlasID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    collections: 'Optional[Dict[str, Atlas]]'
    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this collection.
    """

    contents: 'Optional[Dict[str, AtlasEntry]]'
    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[AtlasID]'
    """
    This collection's content enhances the identified collection, rather than
    being a standalone collection of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[AtlasID]'
    """
    This collection replaces the identified collection. References to the
    replaced collection can be considered equivalent to this collection.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Atlas':
        return cls(
            _from_json_data(AtlasID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[Dict[str, Atlas]], data.get("collections")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[Dict[str, AtlasEntry]], data.get("contents")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[AtlasID], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[AtlasID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.collections is not None:
             data["collections"] = _to_json_data(self.collections)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.contents is not None:
             data["contents"] = _to_json_data(self.contents)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class AtlasEntry:
    """
    An atlas entry, like the Ironlands region entries found in classic
    Ironsworn.
    """

    description: 'MarkdownString'
    features: 'List[MarkdownString]'
    id: 'AtlasEntryID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    quest_starter: 'Optional[MarkdownString]'
    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    tags: 'Optional[Dict[str, Dict[str, Tag]]]'
    your_truth: 'Optional[MarkdownString]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AtlasEntry':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(List[MarkdownString], data.get("features")),
            _from_json_data(AtlasEntryID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[MarkdownString], data.get("quest_starter")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
            _from_json_data(Optional[MarkdownString], data.get("your_truth")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["features"] = _to_json_data(self.features)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.quest_starter is not None:
             data["quest_starter"] = _to_json_data(self.quest_starter)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        if self.your_truth is not None:
             data["your_truth"] = _to_json_data(self.your_truth)
        return data

@dataclass
class AtlasEntryID:
    """
    A unique ID for an AtlasEntry.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AtlasEntryID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AtlasID:
    """
    A unique ID for an Atlas.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AtlasID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AuthorInfo:
    """
    Information on the original creator of this material.
    """

    name: 'str'
    email: 'Optional[str]'
    """
    An optional email contact for the author
    """

    url: 'Optional[str]'
    """
    An optional URL for the author's website.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AuthorInfo':
        return cls(
            _from_json_data(str, data.get("name")),
            _from_json_data(Optional[str], data.get("email")),
            _from_json_data(Optional[str], data.get("url")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["name"] = _to_json_data(self.name)
        if self.email is not None:
             data["email"] = _to_json_data(self.email)
        if self.url is not None:
             data["url"] = _to_json_data(self.url)
        return data

@dataclass
class ChallengeRank:
    """
    Challenge rank, represented as an integer from 1 (troublesome) to 5 (epic).
    """

    value: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ChallengeRank':
        return cls(_from_json_data(int, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class ConditionMeterKey:
    """
    A basic, rollable player character resource specified by the ruleset.
    """

    value: 'DictKey'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ConditionMeterKey':
        return cls(_from_json_data(DictKey, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class ConditionMeterRule:
    """
    Describes a standard player character condition meter.
    """

    description: 'MarkdownString'
    """
    A description of this condition meter.
    """

    label: 'InputLabel'
    max: 'int'
    """
    The maximum value of this meter.
    """

    min: 'int'
    """
    The minimum value of this meter.
    """

    rollable: 'bool'
    """
    Is this meter's `value` usable as a stat in an action roll?
    """

    shared: 'bool'
    """
    Is this condition meter shared by all players?
    """

    value: 'int'
    """
    The current value of this meter.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'ConditionMeterRule':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(bool, data.get("rollable")),
            _from_json_data(bool, data.get("shared")),
            _from_json_data(int, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["label"] = _to_json_data(self.label)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["rollable"] = _to_json_data(self.rollable)
        data["shared"] = _to_json_data(self.shared)
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class CSSColor:
    """
    A CSS color value.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'CSSColor':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSite:
    """
    A delve site with a theme, domain, and denizens.
    """

    denizens: 'List[DelveSiteDenizen]'
    description: 'MarkdownString'
    domain: 'DelveSiteDomainID'
    id: 'DelveSiteID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    rank: 'ChallengeRank'
    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    theme: 'DelveSiteThemeID'
    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    extra_card: 'Optional[str]'
    """
    An additional theme or domain card ID, for use with optional rules in
    Ironsworn: Delve.
    """

    icon: 'Optional[SvgImageURL]'
    region: 'Optional[AtlasEntryID]'
    """
    The ID of an atlas entry representing the region in which this delve site
    is located.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSite':
        return cls(
            _from_json_data(List[DelveSiteDenizen], data.get("denizens")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(DelveSiteDomainID, data.get("domain")),
            _from_json_data(DelveSiteID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(ChallengeRank, data.get("rank")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(DelveSiteThemeID, data.get("theme")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[str], data.get("extra_card")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[AtlasEntryID], data.get("region")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["denizens"] = _to_json_data(self.denizens)
        data["description"] = _to_json_data(self.description)
        data["domain"] = _to_json_data(self.domain)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["rank"] = _to_json_data(self.rank)
        data["source"] = _to_json_data(self.source)
        data["theme"] = _to_json_data(self.theme)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.extra_card is not None:
             data["extra_card"] = _to_json_data(self.extra_card)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.region is not None:
             data["region"] = _to_json_data(self.region)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class DelveSiteDenizen:
    frequency: 'DelveSiteDenizenFrequency'
    id: 'DelveSiteDenizenID'
    """
    The unique Datasworn ID for this item.
    """

    max: 'int'
    min: 'int'
    name: 'Optional[Label]'
    npc: 'Optional[NpcID]'
    """
    The ID of the relevant NPC entry, if one is specified.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDenizen':
        return cls(
            _from_json_data(DelveSiteDenizenFrequency, data.get("frequency")),
            _from_json_data(DelveSiteDenizenID, data.get("id")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(Optional[Label], data.get("name")),
            _from_json_data(Optional[NpcID], data.get("npc")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["frequency"] = _to_json_data(self.frequency)
        data["id"] = _to_json_data(self.id)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        if self.name is not None:
             data["name"] = _to_json_data(self.name)
        if self.npc is not None:
             data["npc"] = _to_json_data(self.npc)
        return data

class DelveSiteDenizenFrequency(Enum):
    COMMON = "common"
    RARE = "rare"
    UNCOMMON = "uncommon"
    UNFORESEEN = "unforeseen"
    VERY_COMMON = "very_common"
    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDenizenFrequency':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class DelveSiteDenizenID:
    """
    A unique ID for a DelveSiteDenizen.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDenizenID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSiteDomain:
    """
    A delve site Domain card.
    """

    dangers: 'List[DelveSiteDomainDangerRow]'
    features: 'List[DelveSiteDomainFeatureRow]'
    id: 'DelveSiteDomainID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    summary: 'MarkdownString'
    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    description: 'Optional[MarkdownString]'
    icon: 'Optional[SvgImageURL]'
    name_oracle: 'Optional[OracleRollableID]'
    """
    An oracle table ID containing place name elements. For examples, see
    oracle ID `delve/oracles/site_name/place/barrow`, and its siblings in
    oracle collection ID `delve/collections/oracles/site_name/place`. These
    oracles are used by the site name oracle from Ironsworn: Delve (ID:
    delve/oracles/site_name/format) to create random names for delve sites.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomain':
        return cls(
            _from_json_data(List[DelveSiteDomainDangerRow], data.get("dangers")),
            _from_json_data(List[DelveSiteDomainFeatureRow], data.get("features")),
            _from_json_data(DelveSiteDomainID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(MarkdownString, data.get("summary")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[OracleRollableID], data.get("name_oracle")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["dangers"] = _to_json_data(self.dangers)
        data["features"] = _to_json_data(self.features)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        data["summary"] = _to_json_data(self.summary)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.name_oracle is not None:
             data["name_oracle"] = _to_json_data(self.name_oracle)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class DelveSiteDomainDangerRow:
    """
    Represents a single Danger entry from a delve site Domain card.
    """

    id: 'DomainDangerRowID'
    """
    The unique Datasworn ID for this item.
    """

    max: 'int'
    """
    High end of the dice range for this table row.
    """

    min: 'int'
    """
    Low end of the dice range for this table row.
    """

    result: 'MarkdownString'
    """
    The primary text content of this row.
    """

    embed_table: 'Optional[OracleRollableID]'
    """
    Hints that the identified table should be rendered inside this table row.
    """

    i18n: 'Optional[I18nHints]'
    icon: 'Optional[SvgImageURL]'
    oracle_rolls: 'Optional[List[OracleRoll]]'
    """
    Further oracle rolls prompted by this table row.
    """

    suggestions: 'Optional[Suggestions]'
    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomainDangerRow':
        return cls(
            _from_json_data(DomainDangerRowID, data.get("id")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(MarkdownString, data.get("result")),
            _from_json_data(Optional[OracleRollableID], data.get("embed_table")),
            _from_json_data(Optional[I18nHints], data.get("i18n")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleRoll]], data.get("oracle_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["result"] = _to_json_data(self.result)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.i18n is not None:
             data["i18n"] = _to_json_data(self.i18n)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.oracle_rolls is not None:
             data["oracle_rolls"] = _to_json_data(self.oracle_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class DelveSiteDomainFeatureRow:
    """
    Represents a single Feature entry from a delve site Domain card.
    """

    id: 'DomainFeatureRowID'
    """
    The unique Datasworn ID for this item.
    """

    max: 'int'
    """
    High end of the dice range for this table row.
    """

    min: 'int'
    """
    Low end of the dice range for this table row.
    """

    result: 'MarkdownString'
    """
    The primary text content of this row.
    """

    embed_table: 'Optional[OracleRollableID]'
    """
    Hints that the identified table should be rendered inside this table row.
    """

    i18n: 'Optional[I18nHints]'
    icon: 'Optional[SvgImageURL]'
    oracle_rolls: 'Optional[List[OracleRoll]]'
    """
    Further oracle rolls prompted by this table row.
    """

    suggestions: 'Optional[Suggestions]'
    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomainFeatureRow':
        return cls(
            _from_json_data(DomainFeatureRowID, data.get("id")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(MarkdownString, data.get("result")),
            _from_json_data(Optional[OracleRollableID], data.get("embed_table")),
            _from_json_data(Optional[I18nHints], data.get("i18n")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleRoll]], data.get("oracle_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["result"] = _to_json_data(self.result)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.i18n is not None:
             data["i18n"] = _to_json_data(self.i18n)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.oracle_rolls is not None:
             data["oracle_rolls"] = _to_json_data(self.oracle_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class DelveSiteDomainID:
    """
    A unique ID for a DelveSiteDomain.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomainID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSiteID:
    """
    A unique ID for a DelveSite.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSiteTheme:
    """
    A delve site theme card.
    """

    dangers: 'List[DelveSiteThemeDangerRow]'
    features: 'List[DelveSiteThemeFeatureRow]'
    id: 'DelveSiteThemeID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    summary: 'MarkdownString'
    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    description: 'Optional[MarkdownString]'
    icon: 'Optional[SvgImageURL]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteTheme':
        return cls(
            _from_json_data(List[DelveSiteThemeDangerRow], data.get("dangers")),
            _from_json_data(List[DelveSiteThemeFeatureRow], data.get("features")),
            _from_json_data(DelveSiteThemeID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(MarkdownString, data.get("summary")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["dangers"] = _to_json_data(self.dangers)
        data["features"] = _to_json_data(self.features)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        data["summary"] = _to_json_data(self.summary)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class DelveSiteThemeDangerRow:
    """
    Represents a single Danger entry from a delve site Theme card.
    """

    id: 'ThemeDangerRowID'
    """
    The unique Datasworn ID for this item.
    """

    max: 'int'
    """
    High end of the dice range for this table row.
    """

    min: 'int'
    """
    Low end of the dice range for this table row.
    """

    result: 'MarkdownString'
    """
    The primary text content of this row.
    """

    embed_table: 'Optional[OracleRollableID]'
    """
    Hints that the identified table should be rendered inside this table row.
    """

    i18n: 'Optional[I18nHints]'
    icon: 'Optional[SvgImageURL]'
    oracle_rolls: 'Optional[List[OracleRoll]]'
    """
    Further oracle rolls prompted by this table row.
    """

    suggestions: 'Optional[Suggestions]'
    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteThemeDangerRow':
        return cls(
            _from_json_data(ThemeDangerRowID, data.get("id")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(MarkdownString, data.get("result")),
            _from_json_data(Optional[OracleRollableID], data.get("embed_table")),
            _from_json_data(Optional[I18nHints], data.get("i18n")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleRoll]], data.get("oracle_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["result"] = _to_json_data(self.result)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.i18n is not None:
             data["i18n"] = _to_json_data(self.i18n)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.oracle_rolls is not None:
             data["oracle_rolls"] = _to_json_data(self.oracle_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class DelveSiteThemeFeatureRow:
    """
    Represents a single Feature entry from a delve site Theme card.
    """

    id: 'ThemeFeatureRowID'
    """
    The unique Datasworn ID for this item.
    """

    max: 'int'
    """
    High end of the dice range for this table row.
    """

    min: 'int'
    """
    Low end of the dice range for this table row.
    """

    result: 'MarkdownString'
    """
    The primary text content of this row.
    """

    embed_table: 'Optional[OracleRollableID]'
    """
    Hints that the identified table should be rendered inside this table row.
    """

    i18n: 'Optional[I18nHints]'
    icon: 'Optional[SvgImageURL]'
    oracle_rolls: 'Optional[List[OracleRoll]]'
    """
    Further oracle rolls prompted by this table row.
    """

    suggestions: 'Optional[Suggestions]'
    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteThemeFeatureRow':
        return cls(
            _from_json_data(ThemeFeatureRowID, data.get("id")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(MarkdownString, data.get("result")),
            _from_json_data(Optional[OracleRollableID], data.get("embed_table")),
            _from_json_data(Optional[I18nHints], data.get("i18n")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleRoll]], data.get("oracle_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["result"] = _to_json_data(self.result)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.i18n is not None:
             data["i18n"] = _to_json_data(self.i18n)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.oracle_rolls is not None:
             data["oracle_rolls"] = _to_json_data(self.oracle_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class DelveSiteThemeID:
    """
    A unique ID for a DelveSiteTheme.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteThemeID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DiceExpression:
    """
    A simple dice roll expression with an optional modifer.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DiceExpression':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DictKey:
    """
    A `snake_case` key used in a Datasworn dictionary object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DictKey':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DomainDangerRowID:
    """
    A unique ID for a DomainDangerRow.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DomainDangerRowID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DomainFeatureRowID:
    """
    A unique ID for a DomainFeatureRow.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DomainFeatureRowID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class ExpansionID:
    """
    The ID of a Datasworn package that relies on an external package to provide
    its ruleset.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ExpansionID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class I18nHint:
    part_of_speech: 'Optional[PartOfSpeech]'
    """
    The part of speech for this string.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'I18nHint':
        return cls(
            _from_json_data(Optional[PartOfSpeech], data.get("part_of_speech")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.part_of_speech is not None:
             data["part_of_speech"] = _to_json_data(self.part_of_speech)
        return data

@dataclass
class I18nHintsTemplate:
    description: 'Optional[I18nHint]'
    detail: 'Optional[I18nHint]'
    result: 'Optional[I18nHint]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'I18nHintsTemplate':
        return cls(
            _from_json_data(Optional[I18nHint], data.get("description")),
            _from_json_data(Optional[I18nHint], data.get("detail")),
            _from_json_data(Optional[I18nHint], data.get("result")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.detail is not None:
             data["detail"] = _to_json_data(self.detail)
        if self.result is not None:
             data["result"] = _to_json_data(self.result)
        return data

@dataclass
class I18nHints:
    """
    Internationalization/localization hints for the text content of this object.
    """

    description: 'Optional[I18nHint]'
    detail: 'Optional[I18nHint]'
    result: 'Optional[I18nHint]'
    template: 'Optional[I18nHintsTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'I18nHints':
        return cls(
            _from_json_data(Optional[I18nHint], data.get("description")),
            _from_json_data(Optional[I18nHint], data.get("detail")),
            _from_json_data(Optional[I18nHint], data.get("result")),
            _from_json_data(Optional[I18nHintsTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.detail is not None:
             data["detail"] = _to_json_data(self.detail)
        if self.result is not None:
             data["result"] = _to_json_data(self.result)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class ImpactCategory:
    """
    Describes a category of standard impacts/debilities.
    """

    contents: 'Dict[str, ImpactRule]'
    """
    A dictionary object of the Impacts in this category.
    """

    description: 'MarkdownString'
    """
    A description of this impact category.
    """

    label: 'InputLabel'
    """
    A label for this impact category.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'ImpactCategory':
        return cls(
            _from_json_data(Dict[str, ImpactRule], data.get("contents")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(InputLabel, data.get("label")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["contents"] = _to_json_data(self.contents)
        data["description"] = _to_json_data(self.description)
        data["label"] = _to_json_data(self.label)
        return data

@dataclass
class ImpactRule:
    """
    Describes a standard impact/debility.
    """

    description: 'MarkdownString'
    """
    A description of this impact.
    """

    label: 'InputLabel'
    """
    The label for this impact.
    """

    permanent: 'bool'
    """
    Is this impact permanent?
    """

    prevents_recovery: 'List[ConditionMeterKey]'
    """
    Any ruleset condition meters that can't recover when this impact is active.
    """

    shared: 'bool'
    """
    Is this impact applied to all players at once?
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'ImpactRule':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(bool, data.get("permanent")),
            _from_json_data(List[ConditionMeterKey], data.get("prevents_recovery")),
            _from_json_data(bool, data.get("shared")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["label"] = _to_json_data(self.label)
        data["permanent"] = _to_json_data(self.permanent)
        data["prevents_recovery"] = _to_json_data(self.prevents_recovery)
        data["shared"] = _to_json_data(self.shared)
        return data

@dataclass
class InputLabel:
    """
    A localized label for an input. In some contexts it may be undesirable to
    render this text, but it should always be exposed to assistive technology
    (e.g. with `aria-label` in HTML).
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'InputLabel':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Label:
    """
    A localized plain text name or label.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Label':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class License:
    """
    An URL pointing to the location where this element's license can be found.
    
    A `null` here indicates that the content provides __no__ license, and is not
    intended for redistribution.
    """

    value: 'WebURL'

    @classmethod
    def from_json_data(cls, data: Any) -> 'License':
        return cls(_from_json_data(WebURL, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class MarkdownString:
    """
    Localized text, formatted in Markdown.
    
    It uses some custom syntax; e.g. `{{table:some_oracle_table_id}}` indicates
    that the referenced oracle table is rendered there part of the source
    material.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MarkdownString':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Move:
    roll_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Move':
        variants: Dict[str, Type[Move]] = {
            "action_roll": MoveActionRoll,
            "no_roll": MoveNoRoll,
            "progress_roll": MoveProgressRoll,
            "special_track": MoveSpecialTrack,
        }

        return variants[data["roll_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class MoveActionRoll(Move):
    """
    A move that makes an action roll.
    """

    id: 'MoveID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    outcomes: 'MoveOutcomes'
    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    trigger: 'TriggerActionRoll'
    """
    Trigger conditions for this move.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    oracles: 'Optional[List[OracleRollableID]]'
    """
    Oracles associated with this move. It's not recommended to roll these
    automatically, as almost all moves present them as an option, not a
    requirement.
    """

    replaces: 'Optional[MoveID]'
    """
    Indicates that this move replaces the identified move. References to the
    replaced move can be considered equivalent to this move.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveActionRoll':
        return cls(
            "action_roll",
            _from_json_data(MoveID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveOutcomes, data.get("outcomes")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(TriggerActionRoll, data.get("trigger")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[List[OracleRollableID]], data.get("oracles")),
            _from_json_data(Optional[MoveID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "action_roll" }
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["outcomes"] = _to_json_data(self.outcomes)
        data["source"] = _to_json_data(self.source)
        data["text"] = _to_json_data(self.text)
        data["trigger"] = _to_json_data(self.trigger)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class MoveNoRoll(Move):
    """
    A move that makes no progress rolls or action rolls.
    """

    id: 'MoveID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    trigger: 'TriggerNoRoll'
    """
    Trigger conditions for this move.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    oracles: 'Optional[List[OracleRollableID]]'
    """
    Oracles associated with this move. It's not recommended to roll these
    automatically, as almost all moves present them as an option, not a
    requirement.
    """

    replaces: 'Optional[MoveID]'
    """
    Indicates that this move replaces the identified move. References to the
    replaced move can be considered equivalent to this move.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveNoRoll':
        return cls(
            "no_roll",
            _from_json_data(MoveID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(TriggerNoRoll, data.get("trigger")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[List[OracleRollableID]], data.get("oracles")),
            _from_json_data(Optional[MoveID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "no_roll" }
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        data["text"] = _to_json_data(self.text)
        data["trigger"] = _to_json_data(self.trigger)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class MoveProgressRoll(Move):
    """
    A progress move that rolls on a standard progress track type (whose features
    are defined by this move object). For progress rolls that use special
    tracks, see MoveSpecialTrack.
    """

    id: 'MoveID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    outcomes: 'MoveOutcomes'
    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    tracks: 'ProgressTrackTypeInfo'
    """
    Describes the common features of progress tracks associated with this move.
    """

    trigger: 'TriggerProgressRoll'
    """
    Trigger conditions for this move.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    oracles: 'Optional[List[OracleRollableID]]'
    """
    Oracles associated with this move. It's not recommended to roll these
    automatically, as almost all moves present them as an option, not a
    requirement.
    """

    replaces: 'Optional[MoveID]'
    """
    Indicates that this move replaces the identified move. References to the
    replaced move can be considered equivalent to this move.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveProgressRoll':
        return cls(
            "progress_roll",
            _from_json_data(MoveID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveOutcomes, data.get("outcomes")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(ProgressTrackTypeInfo, data.get("tracks")),
            _from_json_data(TriggerProgressRoll, data.get("trigger")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[List[OracleRollableID]], data.get("oracles")),
            _from_json_data(Optional[MoveID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "progress_roll" }
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["outcomes"] = _to_json_data(self.outcomes)
        data["source"] = _to_json_data(self.source)
        data["text"] = _to_json_data(self.text)
        data["tracks"] = _to_json_data(self.tracks)
        data["trigger"] = _to_json_data(self.trigger)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class MoveSpecialTrack(Move):
    """
    A progress move that rolls on a special track, such as Legacies (Starforged)
    or Bonds (classic Ironsworn). For progress moves that use standard progress
    tracks, see MoveProgressRoll instead.
    """

    id: 'MoveID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    outcomes: 'MoveOutcomes'
    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    trigger: 'TriggerSpecialTrack'
    """
    Trigger conditions for this move.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    oracles: 'Optional[List[OracleRollableID]]'
    """
    Oracles associated with this move. It's not recommended to roll these
    automatically, as almost all moves present them as an option, not a
    requirement.
    """

    replaces: 'Optional[MoveID]'
    """
    Indicates that this move replaces the identified move. References to the
    replaced move can be considered equivalent to this move.
    """

    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveSpecialTrack':
        return cls(
            "special_track",
            _from_json_data(MoveID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveOutcomes, data.get("outcomes")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(TriggerSpecialTrack, data.get("trigger")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[List[OracleRollableID]], data.get("oracles")),
            _from_json_data(Optional[MoveID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "special_track" }
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["outcomes"] = _to_json_data(self.outcomes)
        data["source"] = _to_json_data(self.source)
        data["text"] = _to_json_data(self.text)
        data["trigger"] = _to_json_data(self.trigger)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class MoveCategory:
    id: 'MoveCategoryID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this collection.
    """

    contents: 'Optional[Dict[str, Move]]'
    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[MoveCategoryID]'
    """
    This collection's content enhances the identified collection, rather than
    being a standalone collection of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[MoveCategoryID]'
    """
    This collection replaces the identified collection. References to the
    replaced collection can be considered equivalent to this collection.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveCategory':
        return cls(
            _from_json_data(MoveCategoryID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[Dict[str, Move]], data.get("contents")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[MoveCategoryID], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[MoveCategoryID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.contents is not None:
             data["contents"] = _to_json_data(self.contents)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class MoveCategoryID:
    """
    A unique ID for a MoveCategory.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveCategoryID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class MoveEnhancement:
    roll_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveEnhancement':
        variants: Dict[str, Type[MoveEnhancement]] = {
            "action_roll": MoveEnhancementActionRoll,
            "no_roll": MoveEnhancementNoRoll,
            "progress_roll": MoveEnhancementProgressRoll,
            "special_track": MoveEnhancementSpecialTrack,
        }

        return variants[data["roll_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class MoveEnhancementActionRoll(MoveEnhancement):
    """
    An object that describes changes to a move. These changes should be applied
    recursively, altering only the specified properties; enhanced arrays should
    be concatencated with the original array value.
    """

    enhances: 'List[MoveIDWildcard]'
    trigger: 'Optional[TriggerActionRollEnhancement]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveEnhancementActionRoll':
        return cls(
            "action_roll",
            _from_json_data(List[MoveIDWildcard], data.get("enhances")),
            _from_json_data(Optional[TriggerActionRollEnhancement], data.get("trigger")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "action_roll" }
        data["enhances"] = _to_json_data(self.enhances)
        if self.trigger is not None:
             data["trigger"] = _to_json_data(self.trigger)
        return data

@dataclass
class MoveEnhancementNoRoll(MoveEnhancement):
    """
    An object that describes changes to a move. These changes should be applied
    recursively, altering only the specified properties; enhanced arrays should
    be concatencated with the original array value.
    """

    enhances: 'List[MoveIDWildcard]'
    trigger: 'Optional[TriggerNoRollEnhancement]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveEnhancementNoRoll':
        return cls(
            "no_roll",
            _from_json_data(List[MoveIDWildcard], data.get("enhances")),
            _from_json_data(Optional[TriggerNoRollEnhancement], data.get("trigger")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "no_roll" }
        data["enhances"] = _to_json_data(self.enhances)
        if self.trigger is not None:
             data["trigger"] = _to_json_data(self.trigger)
        return data

@dataclass
class MoveEnhancementProgressRoll(MoveEnhancement):
    """
    An object that describes changes to a move. These changes should be applied
    recursively, altering only the specified properties; enhanced arrays should
    be concatencated with the original array value.
    """

    enhances: 'List[MoveIDWildcard]'
    trigger: 'Optional[TriggerProgressRollEnhancement]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveEnhancementProgressRoll':
        return cls(
            "progress_roll",
            _from_json_data(List[MoveIDWildcard], data.get("enhances")),
            _from_json_data(Optional[TriggerProgressRollEnhancement], data.get("trigger")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "progress_roll" }
        data["enhances"] = _to_json_data(self.enhances)
        if self.trigger is not None:
             data["trigger"] = _to_json_data(self.trigger)
        return data

@dataclass
class MoveEnhancementSpecialTrack(MoveEnhancement):
    """
    An object that describes changes to a move. These changes should be applied
    recursively, altering only the specified properties; enhanced arrays should
    be concatencated with the original array value.
    """

    enhances: 'List[MoveIDWildcard]'
    trigger: 'Optional[TriggerSpecialTrackEnhancement]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveEnhancementSpecialTrack':
        return cls(
            "special_track",
            _from_json_data(List[MoveIDWildcard], data.get("enhances")),
            _from_json_data(Optional[TriggerSpecialTrackEnhancement], data.get("trigger")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "special_track" }
        data["enhances"] = _to_json_data(self.enhances)
        if self.trigger is not None:
             data["trigger"] = _to_json_data(self.trigger)
        return data

@dataclass
class MoveID:
    """
    A move ID, for a standard move or a unique asset move
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class MoveIDWildcard:
    """
    A move ID with wildcards.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class MoveOutcome:
    text: 'MarkdownString'
    oracle_rolls: 'Optional[List[OracleRoll]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveOutcome':
        return cls(
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(Optional[List[OracleRoll]], data.get("oracle_rolls")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["text"] = _to_json_data(self.text)
        if self.oracle_rolls is not None:
             data["oracle_rolls"] = _to_json_data(self.oracle_rolls)
        return data

@dataclass
class MoveOutcomes:
    """
    A standalone localized description for each move outcome (miss, weak hit,
    or strong hit). This is for for e.g. VTT implementations, where it's often
    useful to display only the rules text relevant to a roll result.
    
      This often requires light editorialization to create text that can stand
    alone without reference to the rest of the move. For example, 'as above'
    (in reference to another move outcome) shouldn't be used here; instead, the
    relevant text should be repeated.
    """

    miss: 'MoveOutcome'
    strong_hit: 'MoveOutcome'
    weak_hit: 'MoveOutcome'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveOutcomes':
        return cls(
            _from_json_data(MoveOutcome, data.get("miss")),
            _from_json_data(MoveOutcome, data.get("strong_hit")),
            _from_json_data(MoveOutcome, data.get("weak_hit")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["miss"] = _to_json_data(self.miss)
        data["strong_hit"] = _to_json_data(self.strong_hit)
        data["weak_hit"] = _to_json_data(self.weak_hit)
        return data

@dataclass
class Npc:
    """
    A non-player character entry, similar to those in Chapter 5 of the Ironsworn
    Rulebook, or Chapter 4 of Starforged.
    """

    description: 'MarkdownString'
    drives: 'List[MarkdownString]'
    features: 'List[MarkdownString]'
    id: 'NpcID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    nature: 'NpcNature'
    rank: 'ChallengeRank'
    """
    The suggested challenge rank for this NPC.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    tactics: 'List[MarkdownString]'
    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    quest_starter: 'Optional[MarkdownString]'
    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    tags: 'Optional[Dict[str, Dict[str, Tag]]]'
    variants: 'Optional[Dict[str, NpcVariant]]'
    your_truth: 'Optional[MarkdownString]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Npc':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(List[MarkdownString], data.get("drives")),
            _from_json_data(List[MarkdownString], data.get("features")),
            _from_json_data(NpcID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(NpcNature, data.get("nature")),
            _from_json_data(ChallengeRank, data.get("rank")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(List[MarkdownString], data.get("tactics")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[MarkdownString], data.get("quest_starter")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
            _from_json_data(Optional[Dict[str, NpcVariant]], data.get("variants")),
            _from_json_data(Optional[MarkdownString], data.get("your_truth")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["drives"] = _to_json_data(self.drives)
        data["features"] = _to_json_data(self.features)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["nature"] = _to_json_data(self.nature)
        data["rank"] = _to_json_data(self.rank)
        data["source"] = _to_json_data(self.source)
        data["tactics"] = _to_json_data(self.tactics)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.quest_starter is not None:
             data["quest_starter"] = _to_json_data(self.quest_starter)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        if self.variants is not None:
             data["variants"] = _to_json_data(self.variants)
        if self.your_truth is not None:
             data["your_truth"] = _to_json_data(self.your_truth)
        return data

@dataclass
class NpcCollection:
    id: 'NpcCollectionID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this collection.
    """

    contents: 'Optional[Dict[str, Npc]]'
    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[NpcCollectionID]'
    """
    This collection's content enhances the identified collection, rather than
    being a standalone collection of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[NpcCollectionID]'
    """
    This collection replaces the identified collection. References to the
    replaced collection can be considered equivalent to this collection.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcCollection':
        return cls(
            _from_json_data(NpcCollectionID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[Dict[str, Npc]], data.get("contents")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[NpcCollectionID], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[NpcCollectionID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.contents is not None:
             data["contents"] = _to_json_data(self.contents)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class NpcCollectionID:
    """
    A unique ID for a NpcCollection.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcCollectionID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class NpcID:
    """
    A unique ID for a Npc.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class NpcNature:
    """
    A localized category label describing the nature of this NPC.
    
    In Ironsworn classic, this is probably the singular form of the parent
    collection's name.
    
    For Starforged, see the table on p. 258 for examples.
    """

    value: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcNature':
        return cls(_from_json_data(Label, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class NpcVariant:
    description: 'MarkdownString'
    id: 'NpcVariantID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    nature: 'NpcNature'
    rank: 'ChallengeRank'
    """
    The suggested challenge rank for this NPC.
    """

    summary: 'Optional[MarkdownString]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcVariant':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(NpcVariantID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(NpcNature, data.get("nature")),
            _from_json_data(ChallengeRank, data.get("rank")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["nature"] = _to_json_data(self.nature)
        data["rank"] = _to_json_data(self.rank)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        return data

@dataclass
class NpcVariantID:
    """
    A unique ID for a NpcVariant.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcVariantID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class ObjectType(Enum):
    ASSET = "asset"
    ASSET_COLLECTION = "asset_collection"
    ATLAS = "atlas"
    ATLAS_ENTRY = "atlas_entry"
    DELVE_SITE = "delve_site"
    DELVE_SITE_DOMAIN = "delve_site_domain"
    DELVE_SITE_THEME = "delve_site_theme"
    MOVE = "move"
    MOVE_CATEGORY = "move_category"
    NPC = "npc"
    NPC_COLLECTION = "npc_collection"
    ORACLE_COLLECTION = "oracle_collection"
    ORACLE_ROLLABLE = "oracle_rollable"
    RARITY = "rarity"
    TRUTH = "truth"
    @classmethod
    def from_json_data(cls, data: Any) -> 'ObjectType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleCollection:
    oracle_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollection':
        variants: Dict[str, Type[OracleCollection]] = {
            "table_shared_details": OracleCollectionTableSharedDetails,
            "table_shared_results": OracleCollectionTableSharedResults,
            "table_shared_rolls": OracleCollectionTableSharedRolls,
            "tables": OracleCollectionTables,
        }

        return variants[data["oracle_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class OracleCollectionTableSharedDetailsColumnLabels:
    """
    The label at the head of each table column. The `roll` key refers to the
    roll column showing the dice range (`min` and `max` on each table row).
    """

    detail: 'Label'
    result: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTableSharedDetailsColumnLabels':
        return cls(
            _from_json_data(Label, data.get("detail")),
            _from_json_data(Label, data.get("result")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["detail"] = _to_json_data(self.detail)
        data["result"] = _to_json_data(self.result)
        return data

@dataclass
class OracleCollectionTableSharedDetails(OracleCollection):
    """
    An OracleCollection representing a single table with multiple roll columns,
    one `result` column, and one `detail` column.
    """

    column_labels: 'OracleCollectionTableSharedDetailsColumnLabels'
    """
    The label at the head of each table column. The `roll` key refers to the
    roll column showing the dice range (`min` and `max` on each table row).
    """

    id: 'OracleCollectionID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this collection.
    """

    contents: 'Optional[Dict[str, OracleColumnDetails]]'
    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[OracleCollectionID]'
    """
    This collection's content enhances the identified collection, rather than
    being a standalone collection of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[OracleCollectionID]'
    """
    This collection replaces the identified collection. References to the
    replaced collection can be considered equivalent to this collection.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTableSharedDetails':
        return cls(
            "table_shared_details",
            _from_json_data(OracleCollectionTableSharedDetailsColumnLabels, data.get("column_labels")),
            _from_json_data(OracleCollectionID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[Dict[str, OracleColumnDetails]], data.get("contents")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[OracleCollectionID], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleCollectionID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "table_shared_details" }
        data["column_labels"] = _to_json_data(self.column_labels)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.contents is not None:
             data["contents"] = _to_json_data(self.contents)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleCollectionTableSharedResultsColumnLabels:
    """
    The label at the head of each table column. The `roll` key refers to the
    roll column showing the dice range (`min` and `max` on each table row).
    """

    result: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTableSharedResultsColumnLabels':
        return cls(
            _from_json_data(Label, data.get("result")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["result"] = _to_json_data(self.result)
        return data

@dataclass
class OracleCollectionTableSharedResults(OracleCollection):
    """
    An OracleCollection representing a single table with multiple roll columns
    and one `result` column.
    """

    column_labels: 'OracleCollectionTableSharedResultsColumnLabels'
    """
    The label at the head of each table column. The `roll` key refers to the
    roll column showing the dice range (`min` and `max` on each table row).
    """

    id: 'OracleCollectionID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this collection.
    """

    contents: 'Optional[Dict[str, OracleColumnSimple]]'
    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[OracleCollectionID]'
    """
    This collection's content enhances the identified collection, rather than
    being a standalone collection of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[OracleCollectionID]'
    """
    This collection replaces the identified collection. References to the
    replaced collection can be considered equivalent to this collection.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTableSharedResults':
        return cls(
            "table_shared_results",
            _from_json_data(OracleCollectionTableSharedResultsColumnLabels, data.get("column_labels")),
            _from_json_data(OracleCollectionID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[Dict[str, OracleColumnSimple]], data.get("contents")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[OracleCollectionID], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleCollectionID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "table_shared_results" }
        data["column_labels"] = _to_json_data(self.column_labels)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.contents is not None:
             data["contents"] = _to_json_data(self.contents)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleCollectionTableSharedRollsColumnLabels:
    """
    Provides column labels for this table. The `roll` key refers to the roll
    column showing the dice range (`min` and `max` on each table row). For all
    other column labels, see the `name` property of each child `OracleColumn`.
    """

    roll: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTableSharedRollsColumnLabels':
        return cls(
            _from_json_data(Label, data.get("roll")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["roll"] = _to_json_data(self.roll)
        return data

@dataclass
class OracleCollectionTableSharedRolls(OracleCollection):
    """
    An OracleCollection representing a single table with one roll column and
    multiple `result` columns.
    """

    column_labels: 'OracleCollectionTableSharedRollsColumnLabels'
    """
    Provides column labels for this table. The `roll` key refers to the roll
    column showing the dice range (`min` and `max` on each table row). For all
    other column labels, see the `name` property of each child `OracleColumn`.
    """

    id: 'OracleCollectionID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this collection.
    """

    contents: 'Optional[Dict[str, OracleColumnSimple]]'
    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[OracleCollectionID]'
    """
    This collection's content enhances the identified collection, rather than
    being a standalone collection of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[OracleCollectionID]'
    """
    This collection replaces the identified collection. References to the
    replaced collection can be considered equivalent to this collection.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTableSharedRolls':
        return cls(
            "table_shared_rolls",
            _from_json_data(OracleCollectionTableSharedRollsColumnLabels, data.get("column_labels")),
            _from_json_data(OracleCollectionID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[Dict[str, OracleColumnSimple]], data.get("contents")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[OracleCollectionID], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleCollectionID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "table_shared_rolls" }
        data["column_labels"] = _to_json_data(self.column_labels)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.contents is not None:
             data["contents"] = _to_json_data(self.contents)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleCollectionTables(OracleCollection):
    """
    An OracleCollection that represents a category or grouping of tables, which
    may themselves be `OracleTablesCollection`s.
    """

    id: 'OracleCollectionID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    collections: 'Optional[Dict[str, OracleCollection]]'
    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this collection.
    """

    contents: 'Optional[Dict[str, OracleTableRollable]]'
    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[OracleCollectionID]'
    """
    This collection's content enhances the identified collection, rather than
    being a standalone collection of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[OracleCollectionID]'
    """
    This collection replaces the identified collection. References to the
    replaced collection can be considered equivalent to this collection.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTables':
        return cls(
            "tables",
            _from_json_data(OracleCollectionID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[Dict[str, OracleCollection]], data.get("collections")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[Dict[str, OracleTableRollable]], data.get("contents")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[OracleCollectionID], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleCollectionID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "tables" }
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.collections is not None:
             data["collections"] = _to_json_data(self.collections)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.contents is not None:
             data["contents"] = _to_json_data(self.contents)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleCollectionID:
    """
    A unique ID for an OracleCollection.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class OracleColumnDetailsOracleType(Enum):
    COLUMN_DETAILS = "column_details"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleColumnDetailsOracleType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleColumnDetails:
    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    id: 'OracleRollableID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary label at the head of this column.
    """

    oracle_type: 'OracleColumnDetailsOracleType'
    rows: 'List[OracleTableRowDetails]'
    """
    An array of objects, each representing a single row of the table.
    """

    color: 'Optional[CSSColor]'
    """
    An optional thematic color for this column. For an example, see "Basic
    Creature Form" (Starforged p. 337)
    """

    icon: 'Optional[SvgImageURL]'
    """
    An optional icon for this column.
    """

    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    replaces: 'Optional[OracleRollableID]'
    """
    Indicates that this object replaces the identified OracleRollable.
    References to the replaced object can be considered equivalent to this
    object.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    Optional secondary text at the head of this column. For best results, this
    should be no more than a few words in length.
    """

    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleColumnDetails':
        return cls(
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(OracleRollableID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(OracleColumnDetailsOracleType, data.get("oracle_type")),
            _from_json_data(List[OracleTableRowDetails], data.get("rows")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleRollableID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["dice"] = _to_json_data(self.dice)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["oracle_type"] = _to_json_data(self.oracle_type)
        data["rows"] = _to_json_data(self.rows)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class OracleColumnSimpleOracleType(Enum):
    COLUMN_SIMPLE = "column_simple"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleColumnSimpleOracleType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleColumnSimple:
    """
    Represents a single column in an OracleCollection.
    """

    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    id: 'OracleRollableID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary label at the head of this column.
    """

    oracle_type: 'OracleColumnSimpleOracleType'
    rows: 'List[OracleTableRowSimple]'
    """
    An array of objects, each representing a single row of the table.
    """

    color: 'Optional[CSSColor]'
    """
    An optional thematic color for this column. For an example, see "Basic
    Creature Form" (Starforged p. 337)
    """

    icon: 'Optional[SvgImageURL]'
    """
    An optional icon for this column.
    """

    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    replaces: 'Optional[OracleRollableID]'
    """
    Indicates that this object replaces the identified OracleRollable.
    References to the replaced object can be considered equivalent to this
    object.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    Optional secondary text at the head of this column. For best results, this
    should be no more than a few words in length.
    """

    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleColumnSimple':
        return cls(
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(OracleRollableID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(OracleColumnSimpleOracleType, data.get("oracle_type")),
            _from_json_data(List[OracleTableRowSimple], data.get("rows")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleRollableID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["dice"] = _to_json_data(self.dice)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["oracle_type"] = _to_json_data(self.oracle_type)
        data["rows"] = _to_json_data(self.rows)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class OracleDuplicateBehavior(Enum):
    """
    Special roll instructions to use when rolling multiple times on a single
    oracle.
    """

    KEEP = "keep"
    """
    Duplicates results should be kept.
    """

    MAKE_IT_WORSE = "make_it_worse"
    """
    Duplicates should be kept, and they compound to make things worse.
    """

    REROLL = "reroll"
    """
    Duplicates results should be re-rolled.
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleDuplicateBehavior':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleMatchBehavior:
    text: 'MarkdownString'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleMatchBehavior':
        return cls(
            _from_json_data(MarkdownString, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["text"] = _to_json_data(self.text)
        return data

@dataclass
class OracleRoll:
    auto: 'bool'
    """
    Both Ironsworn and Starforged explicitly recommend *against* rolling
    all details at once. That said, some oracle results only provide useful
    information once a secondary roll occurs, such as "Action + Theme" or "Roll
    Twice".
    """

    dice: 'DiceExpression'
    duplicates: 'OracleDuplicateBehavior'
    """
    Special rules on how to handle duplicate results, when rolling multiple
    times.
    """

    number_of_rolls: 'int'
    """
    The number of times to roll.
    """

    oracle: 'OracleRollableID'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRoll':
        return cls(
            _from_json_data(bool, data.get("auto")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(OracleDuplicateBehavior, data.get("duplicates")),
            _from_json_data(int, data.get("number_of_rolls")),
            _from_json_data(OracleRollableID, data.get("oracle")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["auto"] = _to_json_data(self.auto)
        data["dice"] = _to_json_data(self.dice)
        data["duplicates"] = _to_json_data(self.duplicates)
        data["number_of_rolls"] = _to_json_data(self.number_of_rolls)
        data["oracle"] = _to_json_data(self.oracle)
        return data

@dataclass
class OracleRollTemplate:
    """
    Provides string templates that may be used in place of the static
    row text from `OracleTableRow#result`, `OracleTableRow#detail`, and
    `OracleTableRow#description`.
    
      These strings are formatted in Markdown, but use a special syntax
    for their placeholders: `{{result:some_oracle_table_id}}`. The
    placeholder should be replaced with the value of a rolled (or selected)
    `OracleTableRow#result` from the target oracle table ID.
    """

    description: 'Optional[TemplateString]'
    """
    A string template that may be used in place of OracleTableRow#description.
    """

    detail: 'Optional[TemplateString]'
    """
    A string template that may be used in place of OracleTableRow#detail.
    """

    result: 'Optional[TemplateString]'
    """
    A string template that may be used in place of OracleTableRow#result.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollTemplate':
        return cls(
            _from_json_data(Optional[TemplateString], data.get("description")),
            _from_json_data(Optional[TemplateString], data.get("detail")),
            _from_json_data(Optional[TemplateString], data.get("result")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.detail is not None:
             data["detail"] = _to_json_data(self.detail)
        if self.result is not None:
             data["result"] = _to_json_data(self.result)
        return data

@dataclass
class OracleRollableID:
    """
    A unique ID for an OracleRollable.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollableID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class OracleTableRollable:
    oracle_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRollable':
        variants: Dict[str, Type[OracleTableRollable]] = {
            "table_details": OracleTableRollableTableDetails,
            "table_simple": OracleTableRollableTableSimple,
        }

        return variants[data["oracle_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class OracleTableRollableTableDetailsColumnLabels:
    """
    The label at the head of each table column. The `roll` key refers to the
    roll column showing the dice range (`min` and `max` on each table row).
    """

    detail: 'Label'
    result: 'Label'
    roll: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRollableTableDetailsColumnLabels':
        return cls(
            _from_json_data(Label, data.get("detail")),
            _from_json_data(Label, data.get("result")),
            _from_json_data(Label, data.get("roll")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["detail"] = _to_json_data(self.detail)
        data["result"] = _to_json_data(self.result)
        data["roll"] = _to_json_data(self.roll)
        return data

@dataclass
class OracleTableRollableTableDetailsRecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRollableTableDetailsRecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class OracleTableRollableTableDetails(OracleTableRollable):
    """
    A rollable oracle table with one roll column, one `result` column, and one
    `detail` column.
    """

    column_labels: 'OracleTableRollableTableDetailsColumnLabels'
    """
    The label at the head of each table column. The `roll` key refers to the
    roll column showing the dice range (`min` and `max` on each table row).
    """

    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    id: 'OracleRollableID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    rows: 'List[OracleTableRowDetails]'
    """
    An array of objects, each representing a single row of the table.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    description: 'Optional[MarkdownString]'
    """
    A longer description of the oracle table's intended usage, which might
    include multiple paragraphs. If it's only a couple sentences, use the
    `summary` key instead.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon that represents this table.
    """

    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[OracleTableRollableTableDetailsRecommendedRolls]'
    replaces: 'Optional[OracleRollableID]'
    """
    Indicates that this object replaces the identified OracleRollable.
    References to the replaced object can be considered equivalent to this
    object.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of the oracle table's intended usage, no more than a few
    sentences in length. This is intended for use in application tooltips
    and similar sorts of hints. Longer text should use the "description" key
    instead.
    """

    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRollableTableDetails':
        return cls(
            "table_details",
            _from_json_data(OracleTableRollableTableDetailsColumnLabels, data.get("column_labels")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(OracleRollableID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[OracleTableRowDetails], data.get("rows")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleTableRollableTableDetailsRecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[OracleRollableID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "table_details" }
        data["column_labels"] = _to_json_data(self.column_labels)
        data["dice"] = _to_json_data(self.dice)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["rows"] = _to_json_data(self.rows)
        data["source"] = _to_json_data(self.source)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleTableRollableTableSimpleColumnLabels:
    """
    The label at the head of each table column. The `roll` key refers to the
    roll column showing the dice range (`min` and `max` on each table row).
    """

    result: 'Label'
    roll: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRollableTableSimpleColumnLabels':
        return cls(
            _from_json_data(Label, data.get("result")),
            _from_json_data(Label, data.get("roll")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["result"] = _to_json_data(self.result)
        data["roll"] = _to_json_data(self.roll)
        return data

@dataclass
class OracleTableRollableTableSimpleRecommendedRolls:
    max: 'int'
    min: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRollableTableSimpleRecommendedRolls':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        return data

@dataclass
class OracleTableRollableTableSimple(OracleTableRollable):
    """
    Represents a basic rollable oracle table with one roll column and one
    `result` column.
    """

    column_labels: 'OracleTableRollableTableSimpleColumnLabels'
    """
    The label at the head of each table column. The `roll` key refers to the
    roll column showing the dice range (`min` and `max` on each table row).
    """

    dice: 'DiceExpression'
    """
    The roll used to select a result on this oracle.
    """

    id: 'OracleRollableID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    rows: 'List[OracleTableRowSimple]'
    """
    An array of objects, each representing a single row of the table.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    description: 'Optional[MarkdownString]'
    """
    A longer description of the oracle table's intended usage, which might
    include multiple paragraphs. If it's only a couple sentences, use the
    `summary` key instead.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon that represents this table.
    """

    match: 'Optional[OracleMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    recommended_rolls: 'Optional[OracleTableRollableTableSimpleRecommendedRolls]'
    replaces: 'Optional[OracleRollableID]'
    """
    Indicates that this object replaces the identified OracleRollable.
    References to the replaced object can be considered equivalent to this
    object.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of the oracle table's intended usage, no more than a few
    sentences in length. This is intended for use in application tooltips
    and similar sorts of hints. Longer text should use the "description" key
    instead.
    """

    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRollableTableSimple':
        return cls(
            "table_simple",
            _from_json_data(OracleTableRollableTableSimpleColumnLabels, data.get("column_labels")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(OracleRollableID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[OracleTableRowSimple], data.get("rows")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[OracleMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleTableRollableTableSimpleRecommendedRolls], data.get("recommended_rolls")),
            _from_json_data(Optional[OracleRollableID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data = { "oracle_type": "table_simple" }
        data["column_labels"] = _to_json_data(self.column_labels)
        data["dice"] = _to_json_data(self.dice)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["rows"] = _to_json_data(self.rows)
        data["source"] = _to_json_data(self.source)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.recommended_rolls is not None:
             data["recommended_rolls"] = _to_json_data(self.recommended_rolls)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class OracleTableRowDetails:
    """
    Represents a row in an oracle table that provides additional details.
    """

    detail: 'MarkdownString'
    max: 'int'
    """
    High end of the dice range for this table row.
    """

    min: 'int'
    """
    Low end of the dice range for this table row.
    """

    result: 'MarkdownString'
    """
    The primary text content of this row.
    """

    embed_table: 'Optional[OracleRollableID]'
    """
    Hints that the identified table should be rendered inside this table row.
    """

    i18n: 'Optional[I18nHints]'
    icon: 'Optional[SvgImageURL]'
    oracle_rolls: 'Optional[List[OracleRoll]]'
    """
    Further oracle rolls prompted by this table row.
    """

    suggestions: 'Optional[Suggestions]'
    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRowDetails':
        return cls(
            _from_json_data(MarkdownString, data.get("detail")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(MarkdownString, data.get("result")),
            _from_json_data(Optional[OracleRollableID], data.get("embed_table")),
            _from_json_data(Optional[I18nHints], data.get("i18n")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleRoll]], data.get("oracle_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["detail"] = _to_json_data(self.detail)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["result"] = _to_json_data(self.result)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.i18n is not None:
             data["i18n"] = _to_json_data(self.i18n)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.oracle_rolls is not None:
             data["oracle_rolls"] = _to_json_data(self.oracle_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class OracleTableRowSimple:
    """
    Represents a row in an oracle table.
    """

    max: 'int'
    """
    High end of the dice range for this table row.
    """

    min: 'int'
    """
    Low end of the dice range for this table row.
    """

    result: 'MarkdownString'
    """
    The primary text content of this row.
    """

    embed_table: 'Optional[OracleRollableID]'
    """
    Hints that the identified table should be rendered inside this table row.
    """

    i18n: 'Optional[I18nHints]'
    icon: 'Optional[SvgImageURL]'
    oracle_rolls: 'Optional[List[OracleRoll]]'
    """
    Further oracle rolls prompted by this table row.
    """

    suggestions: 'Optional[Suggestions]'
    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRowSimple':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(MarkdownString, data.get("result")),
            _from_json_data(Optional[OracleRollableID], data.get("embed_table")),
            _from_json_data(Optional[I18nHints], data.get("i18n")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleRoll]], data.get("oracle_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["result"] = _to_json_data(self.result)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.i18n is not None:
             data["i18n"] = _to_json_data(self.i18n)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.oracle_rolls is not None:
             data["oracle_rolls"] = _to_json_data(self.oracle_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

class OracleTablesCollectionOracleType(Enum):
    """
    A grouping of separate tables.
    """

    TABLES = "tables"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTablesCollectionOracleType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleTablesCollection:
    """
    An OracleCollection that represents a category or grouping of tables, which
    may themselves be `OracleTablesCollection`s.
    """

    id: 'OracleCollectionID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    oracle_type: 'OracleTablesCollectionOracleType'
    """
    A grouping of separate tables.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    collections: 'Optional[Dict[str, OracleCollection]]'
    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this collection.
    """

    contents: 'Optional[Dict[str, OracleTableRollable]]'
    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[OracleCollectionID]'
    """
    This collection's content enhances the identified collection, rather than
    being a standalone collection of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[OracleCollectionID]'
    """
    This collection replaces the identified collection. References to the
    replaced collection can be considered equivalent to this collection.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """

    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTablesCollection':
        return cls(
            _from_json_data(OracleCollectionID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(OracleTablesCollectionOracleType, data.get("oracle_type")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[Dict[str, OracleCollection]], data.get("collections")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[Dict[str, OracleTableRollable]], data.get("contents")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[OracleCollectionID], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleCollectionID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["oracle_type"] = _to_json_data(self.oracle_type)
        data["source"] = _to_json_data(self.source)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.collections is not None:
             data["collections"] = _to_json_data(self.collections)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.contents is not None:
             data["contents"] = _to_json_data(self.contents)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

class PartOfSpeech(Enum):
    ADJECTIVE = "adjective"
    """
    An adjective.
    """

    ADJECTIVE_AS_PROPER_NOUN = "adjective_as_proper_noun"
    """
    An adjective used as a proper noun.
    """

    ADJUNCT_COMMON_NOUN = "adjunct_common_noun"
    """
    A common noun used as an adjective, to modify another noun.
    """

    ADJUNCT_PROPER_NOUN = "adjunct_proper_noun"
    """
    A proper noun used as an adjective, to modify another noun.
    """

    ATTRIBUTIVE_VERB = "attributive_verb"
    """
    A verb used as an adjective, to modify a noun.
    """

    COMMON_NOUN = "common_noun"
    """
    A common noun.
    """

    COMMON_NOUN_AS_PROPER_NOUN = "common_noun_as_proper_noun"
    """
    An common noun used as a proper noun.
    """

    GERUND = "gerund"
    """
    Gerund or present participle of a verb, e.g. "going", "seeing", "waving"
    """

    PROPER_NOUN = "proper_noun"
    """
    A proper noun.
    """

    VERB = "verb"
    """
    A verb in present tense
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'PartOfSpeech':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class ProgressRollMethod(Enum):
    MISS = "miss"
    """
    An automatic miss.
    """

    PROGRESS_ROLL = "progress_roll"
    """
    Make a progress roll on a progress track associated with this move.
    """

    STRONG_HIT = "strong_hit"
    """
    An automatic strong hit.
    """

    WEAK_HIT = "weak_hit"
    """
    An automatic weak hit.
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'ProgressRollMethod':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class ProgressRollOptionUsing(Enum):
    PROGRESS_TRACK = "progress_track"
    @classmethod
    def from_json_data(cls, data: Any) -> 'ProgressRollOptionUsing':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class ProgressRollOption:
    using: 'ProgressRollOptionUsing'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ProgressRollOption':
        return cls(
            _from_json_data(ProgressRollOptionUsing, data.get("using")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["using"] = _to_json_data(self.using)
        return data

@dataclass
class ProgressTrackTypeInfo:
    """
    Describes the features of a type of progress track.
    """

    category: 'Label'
    """
    A category label for progress tracks of this type.
    """

    controls: 'Optional[Dict[str, Any]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ProgressTrackTypeInfo':
        return cls(
            _from_json_data(Label, data.get("category")),
            _from_json_data(Optional[Dict[str, Any]], data.get("controls")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["category"] = _to_json_data(self.category)
        if self.controls is not None:
             data["controls"] = _to_json_data(self.controls)
        return data

@dataclass
class Rarity:
    """
    A rarity, as described in Ironsworn: Delve.
    """

    asset: 'AssetID'
    """
    The asset augmented by this rarity.
    """

    description: 'MarkdownString'
    id: 'RarityID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    xp_cost: 'int'
    """
    From Ironsworn: Delve, p. 174:
    
          Some assets will bring a rarity into play more often than others, so
    the experience point cost for a rarity will vary by the linked asset. These
    costs are shown in the tables on page 175.
    
          If you are playing solo, and arent concerned with the relative
    balance of rarity abilities, you can ignore these variable costs. If so,
    spend 3 experience points to purchase a rarity.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    icon: 'Optional[SvgImageURL]'
    suggestions: 'Optional[Suggestions]'
    tags: 'Optional[Dict[str, Dict[str, Tag]]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Rarity':
        return cls(
            _from_json_data(AssetID, data.get("asset")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(RarityID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(int, data.get("xp_cost")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["asset"] = _to_json_data(self.asset)
        data["description"] = _to_json_data(self.description)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        data["xp_cost"] = _to_json_data(self.xp_cost)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class RarityID:
    """
    A unique ID for a Rarity.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RarityID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class RollableValue:
    using: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValue':
        variants: Dict[str, Type[RollableValue]] = {
            "asset_control": RollableValueAssetControl,
            "asset_option": RollableValueAssetOption,
            "attached_asset_control": RollableValueAttachedAssetControl,
            "attached_asset_option": RollableValueAttachedAssetOption,
            "condition_meter": RollableValueConditionMeter,
            "custom": RollableValueCustom,
            "stat": RollableValueStat,
        }

        return variants[data["using"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class RollableValueAssetControl(RollableValue):
    """
    A reference to the value of an asset control.
    """

    assets: 'List[AssetIDWildcard]'
    control: 'DictKey'
    """
    The dictionary key of the asset control field.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueAssetControl':
        return cls(
            "asset_control",
            _from_json_data(List[AssetIDWildcard], data.get("assets")),
            _from_json_data(DictKey, data.get("control")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "asset_control" }
        data["assets"] = _to_json_data(self.assets)
        data["control"] = _to_json_data(self.control)
        return data

@dataclass
class RollableValueAssetOption(RollableValue):
    """
    A reference to the value of an asset option.
    """

    assets: 'List[AssetIDWildcard]'
    option: 'DictKey'
    """
    The dictionary key of the asset option field.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueAssetOption':
        return cls(
            "asset_option",
            _from_json_data(List[AssetIDWildcard], data.get("assets")),
            _from_json_data(DictKey, data.get("option")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "asset_option" }
        data["assets"] = _to_json_data(self.assets)
        data["option"] = _to_json_data(self.option)
        return data

@dataclass
class RollableValueAttachedAssetControl(RollableValue):
    """
    A reference to the value of an attached asset control. For example, a Module
    asset could use this to roll using the `integrity` control of an attached
    Vehicle.
    """

    control: 'DictKey'
    """
    The dictionary key of the asset control field.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueAttachedAssetControl':
        return cls(
            "attached_asset_control",
            _from_json_data(DictKey, data.get("control")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "attached_asset_control" }
        data["control"] = _to_json_data(self.control)
        return data

@dataclass
class RollableValueAttachedAssetOption(RollableValue):
    """
    A reference to the value of an attached asset option.
    """

    option: 'DictKey'
    """
    The dictionary key of the asset option field.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueAttachedAssetOption':
        return cls(
            "attached_asset_option",
            _from_json_data(DictKey, data.get("option")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "attached_asset_option" }
        data["option"] = _to_json_data(self.option)
        return data

@dataclass
class RollableValueConditionMeter(RollableValue):
    """
    A reference to the value of a standard player condition meter.
    """

    condition_meter: 'ConditionMeterKey'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueConditionMeter':
        return cls(
            "condition_meter",
            _from_json_data(ConditionMeterKey, data.get("condition_meter")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "condition_meter" }
        data["condition_meter"] = _to_json_data(self.condition_meter)
        return data

@dataclass
class RollableValueCustom(RollableValue):
    """
    An arbitrary static integer value with a label.
    """

    label: 'InputLabel'
    value: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueCustom':
        return cls(
            "custom",
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(int, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "custom" }
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class RollableValueStat(RollableValue):
    """
    A reference to the value of a standard player character stat.
    """

    stat: 'StatKey'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueStat':
        return cls(
            "stat",
            _from_json_data(StatKey, data.get("stat")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "stat" }
        data["stat"] = _to_json_data(self.stat)
        return data

@dataclass
class Rules:
    """
    Describes rules for player characters in this ruleset, such as stats and
    condition meters.
    """

    condition_meters: 'Dict[str, ConditionMeterRule]'
    """
    Describes the standard condition meters used by player characters in this
    ruleset.
    """

    impacts: 'Dict[str, ImpactCategory]'
    """
    Describes the standard impacts/debilities used by player characters in this
    ruleset.
    """

    special_tracks: 'Dict[str, SpecialTrackRule]'
    """
    Describes the special tracks used by player characters in this ruleset, like
    Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
    """

    stats: 'Dict[str, StatRule]'
    """
    Describes the standard stats used by player characters in this ruleset.
    """

    tags: 'Dict[str, TagRule]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Rules':
        return cls(
            _from_json_data(Dict[str, ConditionMeterRule], data.get("condition_meters")),
            _from_json_data(Dict[str, ImpactCategory], data.get("impacts")),
            _from_json_data(Dict[str, SpecialTrackRule], data.get("special_tracks")),
            _from_json_data(Dict[str, StatRule], data.get("stats")),
            _from_json_data(Dict[str, TagRule], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["condition_meters"] = _to_json_data(self.condition_meters)
        data["impacts"] = _to_json_data(self.impacts)
        data["special_tracks"] = _to_json_data(self.special_tracks)
        data["stats"] = _to_json_data(self.stats)
        data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class RulesExpansion:
    """
    Describes rules for player characters in this ruleset, such as stats and
    condition meters.
    """

    condition_meters: 'Optional[Dict[str, ConditionMeterRule]]'
    """
    Describes the standard condition meters used by player characters in this
    ruleset.
    """

    impacts: 'Optional[Dict[str, ImpactCategory]]'
    """
    Describes the standard impacts/debilities used by player characters in this
    ruleset.
    """

    special_tracks: 'Optional[Dict[str, SpecialTrackRule]]'
    """
    Describes the special tracks used by player characters in this ruleset, like
    Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
    """

    stats: 'Optional[Dict[str, StatRule]]'
    """
    Describes the standard stats used by player characters in this ruleset.
    """

    tags: 'Optional[Dict[str, TagRule]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RulesExpansion':
        return cls(
            _from_json_data(Optional[Dict[str, ConditionMeterRule]], data.get("condition_meters")),
            _from_json_data(Optional[Dict[str, ImpactCategory]], data.get("impacts")),
            _from_json_data(Optional[Dict[str, SpecialTrackRule]], data.get("special_tracks")),
            _from_json_data(Optional[Dict[str, StatRule]], data.get("stats")),
            _from_json_data(Optional[Dict[str, TagRule]], data.get("tags")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.condition_meters is not None:
             data["condition_meters"] = _to_json_data(self.condition_meters)
        if self.impacts is not None:
             data["impacts"] = _to_json_data(self.impacts)
        if self.special_tracks is not None:
             data["special_tracks"] = _to_json_data(self.special_tracks)
        if self.stats is not None:
             data["stats"] = _to_json_data(self.stats)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        return data

@dataclass
class RulesetID:
    """
    The ID of standalone Datasworn package that describes its own ruleset.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RulesetID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class SelectEnhancementFieldChoiceChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectEnhancementFieldChoiceChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectEnhancementFieldChoice:
    """
    Represents an option in a list of choices.
    """

    choice_type: 'SelectEnhancementFieldChoiceChoiceType'
    label: 'InputLabel'
    enhance_asset: 'Optional[AssetEnhancement]'
    enhance_moves: 'Optional[List[MoveEnhancement]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectEnhancementFieldChoice':
        return cls(
            _from_json_data(SelectEnhancementFieldChoiceChoiceType, data.get("choice_type")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(Optional[AssetEnhancement], data.get("enhance_asset")),
            _from_json_data(Optional[List[MoveEnhancement]], data.get("enhance_moves")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["choice_type"] = _to_json_data(self.choice_type)
        data["label"] = _to_json_data(self.label)
        if self.enhance_asset is not None:
             data["enhance_asset"] = _to_json_data(self.enhance_asset)
        if self.enhance_moves is not None:
             data["enhance_moves"] = _to_json_data(self.enhance_moves)
        return data

@dataclass
class SelectValueFieldChoice:
    using: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoice':
        variants: Dict[str, Type[SelectValueFieldChoice]] = {
            "asset_control": SelectValueFieldChoiceAssetControl,
            "asset_option": SelectValueFieldChoiceAssetOption,
            "attached_asset_control": SelectValueFieldChoiceAttachedAssetControl,
            "attached_asset_option": SelectValueFieldChoiceAttachedAssetOption,
            "condition_meter": SelectValueFieldChoiceConditionMeter,
            "custom": SelectValueFieldChoiceCustom,
            "stat": SelectValueFieldChoiceStat,
        }

        return variants[data["using"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

class SelectValueFieldChoiceAssetControlChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAssetControlChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceAssetControl(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    assets: 'List[AssetIDWildcard]'
    choice_type: 'SelectValueFieldChoiceAssetControlChoiceType'
    control: 'DictKey'
    """
    The dictionary key of the asset control field.
    """

    label: 'InputLabel'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAssetControl':
        return cls(
            "asset_control",
            _from_json_data(List[AssetIDWildcard], data.get("assets")),
            _from_json_data(SelectValueFieldChoiceAssetControlChoiceType, data.get("choice_type")),
            _from_json_data(DictKey, data.get("control")),
            _from_json_data(InputLabel, data.get("label")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "asset_control" }
        data["assets"] = _to_json_data(self.assets)
        data["choice_type"] = _to_json_data(self.choice_type)
        data["control"] = _to_json_data(self.control)
        data["label"] = _to_json_data(self.label)
        return data

class SelectValueFieldChoiceAssetOptionChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAssetOptionChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceAssetOption(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    assets: 'List[AssetIDWildcard]'
    choice_type: 'SelectValueFieldChoiceAssetOptionChoiceType'
    label: 'InputLabel'
    option: 'DictKey'
    """
    The dictionary key of the asset option field.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAssetOption':
        return cls(
            "asset_option",
            _from_json_data(List[AssetIDWildcard], data.get("assets")),
            _from_json_data(SelectValueFieldChoiceAssetOptionChoiceType, data.get("choice_type")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(DictKey, data.get("option")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "asset_option" }
        data["assets"] = _to_json_data(self.assets)
        data["choice_type"] = _to_json_data(self.choice_type)
        data["label"] = _to_json_data(self.label)
        data["option"] = _to_json_data(self.option)
        return data

class SelectValueFieldChoiceAttachedAssetControlChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAttachedAssetControlChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceAttachedAssetControl(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    choice_type: 'SelectValueFieldChoiceAttachedAssetControlChoiceType'
    control: 'DictKey'
    """
    The dictionary key of the asset control field.
    """

    label: 'InputLabel'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAttachedAssetControl':
        return cls(
            "attached_asset_control",
            _from_json_data(SelectValueFieldChoiceAttachedAssetControlChoiceType, data.get("choice_type")),
            _from_json_data(DictKey, data.get("control")),
            _from_json_data(InputLabel, data.get("label")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "attached_asset_control" }
        data["choice_type"] = _to_json_data(self.choice_type)
        data["control"] = _to_json_data(self.control)
        data["label"] = _to_json_data(self.label)
        return data

class SelectValueFieldChoiceAttachedAssetOptionChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAttachedAssetOptionChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceAttachedAssetOption(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    choice_type: 'SelectValueFieldChoiceAttachedAssetOptionChoiceType'
    label: 'InputLabel'
    option: 'DictKey'
    """
    The dictionary key of the asset option field.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAttachedAssetOption':
        return cls(
            "attached_asset_option",
            _from_json_data(SelectValueFieldChoiceAttachedAssetOptionChoiceType, data.get("choice_type")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(DictKey, data.get("option")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "attached_asset_option" }
        data["choice_type"] = _to_json_data(self.choice_type)
        data["label"] = _to_json_data(self.label)
        data["option"] = _to_json_data(self.option)
        return data

class SelectValueFieldChoiceConditionMeterChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceConditionMeterChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceConditionMeter(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    choice_type: 'SelectValueFieldChoiceConditionMeterChoiceType'
    condition_meter: 'ConditionMeterKey'
    label: 'InputLabel'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceConditionMeter':
        return cls(
            "condition_meter",
            _from_json_data(SelectValueFieldChoiceConditionMeterChoiceType, data.get("choice_type")),
            _from_json_data(ConditionMeterKey, data.get("condition_meter")),
            _from_json_data(InputLabel, data.get("label")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "condition_meter" }
        data["choice_type"] = _to_json_data(self.choice_type)
        data["condition_meter"] = _to_json_data(self.condition_meter)
        data["label"] = _to_json_data(self.label)
        return data

class SelectValueFieldChoiceCustomChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceCustomChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceCustom(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    choice_type: 'SelectValueFieldChoiceCustomChoiceType'
    label: 'InputLabel'
    value: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceCustom':
        return cls(
            "custom",
            _from_json_data(SelectValueFieldChoiceCustomChoiceType, data.get("choice_type")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(int, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "custom" }
        data["choice_type"] = _to_json_data(self.choice_type)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        return data

class SelectValueFieldChoiceStatChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceStatChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceStat(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    choice_type: 'SelectValueFieldChoiceStatChoiceType'
    label: 'InputLabel'
    stat: 'StatKey'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceStat':
        return cls(
            "stat",
            _from_json_data(SelectValueFieldChoiceStatChoiceType, data.get("choice_type")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(StatKey, data.get("stat")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "stat" }
        data["choice_type"] = _to_json_data(self.choice_type)
        data["label"] = _to_json_data(self.label)
        data["stat"] = _to_json_data(self.stat)
        return data

@dataclass
class SemanticVersion:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SemanticVersion':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class SourceInfo:
    """
    Metadata describing the original source of this item
    """

    authors: 'List[AuthorInfo]'
    """
    Lists authors credited by the source material.
    """

    date: 'datetime'
    """
    The date of the source documents's last update, formatted YYYY-MM-DD.
    Required because it's used to determine whether the data needs updating.
    """

    license: 'License'
    title: 'str'
    """
    The title of the source document.
    """

    url: 'WebURL'
    """
    A URL where the source document is available.
    """

    page: 'Optional[int]'
    """
    The page number where this item is described in full.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'SourceInfo':
        return cls(
            _from_json_data(List[AuthorInfo], data.get("authors")),
            _from_json_data(datetime, data.get("date")),
            _from_json_data(License, data.get("license")),
            _from_json_data(str, data.get("title")),
            _from_json_data(WebURL, data.get("url")),
            _from_json_data(Optional[int], data.get("page")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["authors"] = _to_json_data(self.authors)
        data["date"] = _to_json_data(self.date)
        data["license"] = _to_json_data(self.license)
        data["title"] = _to_json_data(self.title)
        data["url"] = _to_json_data(self.url)
        if self.page is not None:
             data["page"] = _to_json_data(self.page)
        return data

class SpecialTrackRollMethod(Enum):
    ALL = "all"
    """
    Use _every_ roll option at once.
    """

    HIGHEST = "highest"
    """
    Use the roll option with the best/highest value.
    """

    LOWEST = "lowest"
    """
    Use the roll option with the worst/lowest value.
    """

    MISS = "miss"
    """
    An automatic miss.
    """

    PLAYER_CHOICE = "player_choice"
    """
    The player chooses which roll option to use.
    """

    STRONG_HIT = "strong_hit"
    """
    An automatic strong hit.
    """

    WEAK_HIT = "weak_hit"
    """
    An automatic weak hit.
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'SpecialTrackRollMethod':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SpecialTrackRule:
    """
    Describes a special track like Bonds (classic Ironsworn), Failure (Delve),
    or Legacies (Starforged).
    """

    description: 'MarkdownString'
    """
    A description of this special track.
    """

    label: 'InputLabel'
    """
    A label for this special track.
    """

    optional: 'bool'
    """
    Is this track an optional rule?
    """

    shared: 'bool'
    """
    Is this track shared by all players?
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'SpecialTrackRule':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(bool, data.get("optional")),
            _from_json_data(bool, data.get("shared")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["label"] = _to_json_data(self.label)
        data["optional"] = _to_json_data(self.optional)
        data["shared"] = _to_json_data(self.shared)
        return data

@dataclass
class SpecialTrackType:
    """
    Special, ruleset-specific progress tracks. Usually, one exists per player
    character, and they persist through the life of the player character.
    'Canonical' examples:
      * `bonds_track`, described in the Ironsworn Rulebook. For the Starforged
    legacy track, use `bonds_legacy` instead.
      * `failure_track`, described in Ironsworn: Delve
      * `quests_legacy`, `bonds_legacy`, and `discoveries_legacy`, described
    Ironsworn: Starforged
    
    """

    value: 'DictKey'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SpecialTrackType':
        return cls(_from_json_data(DictKey, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class StatKey:
    """
    A basic player character stat.
    """

    value: 'DictKey'

    @classmethod
    def from_json_data(cls, data: Any) -> 'StatKey':
        return cls(_from_json_data(DictKey, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class StatRule:
    """
    Describes a standard player character stat.
    """

    description: 'MarkdownString'
    """
    A description of this stat.
    """

    label: 'InputLabel'
    """
    A label for this stat.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'StatRule':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(InputLabel, data.get("label")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["label"] = _to_json_data(self.label)
        return data

@dataclass
class Suggestions:
    assets: 'Optional[List[AssetID]]'
    atlas: 'Optional[List[AtlasEntryID]]'
    moves: 'Optional[List[MoveID]]'
    npcs: 'Optional[List[NpcID]]'
    oracles: 'Optional[List[OracleRollableID]]'
    rarities: 'Optional[List[RarityID]]'
    site_domains: 'Optional[List[DelveSiteDomainID]]'
    site_themes: 'Optional[List[DelveSiteThemeID]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Suggestions':
        return cls(
            _from_json_data(Optional[List[AssetID]], data.get("assets")),
            _from_json_data(Optional[List[AtlasEntryID]], data.get("atlas")),
            _from_json_data(Optional[List[MoveID]], data.get("moves")),
            _from_json_data(Optional[List[NpcID]], data.get("npcs")),
            _from_json_data(Optional[List[OracleRollableID]], data.get("oracles")),
            _from_json_data(Optional[List[RarityID]], data.get("rarities")),
            _from_json_data(Optional[List[DelveSiteDomainID]], data.get("site_domains")),
            _from_json_data(Optional[List[DelveSiteThemeID]], data.get("site_themes")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.assets is not None:
             data["assets"] = _to_json_data(self.assets)
        if self.atlas is not None:
             data["atlas"] = _to_json_data(self.atlas)
        if self.moves is not None:
             data["moves"] = _to_json_data(self.moves)
        if self.npcs is not None:
             data["npcs"] = _to_json_data(self.npcs)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.rarities is not None:
             data["rarities"] = _to_json_data(self.rarities)
        if self.site_domains is not None:
             data["site_domains"] = _to_json_data(self.site_domains)
        if self.site_themes is not None:
             data["site_themes"] = _to_json_data(self.site_themes)
        return data

@dataclass
class SvgImageURL:
    """
    A relative (local) URL pointing to a vector image in the SVG format.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SvgImageURL':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Tag:
    value: 'Any'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Tag':
        return cls(_from_json_data(Any, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class TagRule:
    value_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TagRule':
        variants: Dict[str, Type[TagRule]] = {
            "asset": TagRuleAsset,
            "asset_collection": TagRuleAssetCollection,
            "atlas": TagRuleAtlas,
            "atlas_entry": TagRuleAtlasEntry,
            "boolean": TagRuleBoolean,
            "delve_site": TagRuleDelveSite,
            "delve_site_domain": TagRuleDelveSiteDomain,
            "delve_site_theme": TagRuleDelveSiteTheme,
            "enum": TagRuleEnum,
            "integer": TagRuleInteger,
            "move": TagRuleMove,
            "move_category": TagRuleMoveCategory,
            "npc": TagRuleNpc,
            "npc_collection": TagRuleNpcCollection,
            "oracle_collection": TagRuleOracleCollection,
            "oracle_rollable": TagRuleOracleRollable,
            "rarity": TagRuleRarity,
            "truth": TagRuleTruth,
        }

        return variants[data["value_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class TagRuleAsset(TagRule):
    applies_to: 'List[ObjectType]'
    description: 'MarkdownString'
    wildcard: 'bool'
    """
    If `true`, this field accepts an array of wildcard IDs. If `false`, this
    field accepts a single non-wildcard ID.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TagRuleAsset':
        return cls(
            "asset",
            _from_json_data(List[ObjectType], data.get("applies_to")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(bool, data.get("wildcard")),
        )

    def to_json_data(self) -> Any:
        data = { "value_type": "asset" }
        data["applies_to"] = _to_json_data(self.applies_to)
        data["description"] = _to_json_data(self.description)
        data["wildcard"] = _to_json_data(self.wildcard)
        return data

@dataclass
class TagRuleAssetCollection(TagRule):
    applies_to: 'List[ObjectType]'
    description: 'MarkdownString'
    wildcard: 'bool'
    """
    If `true`, this field accepts an array of wildcard IDs. If `false`, this
    field accepts a single non-wildcard ID.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TagRuleAssetCollection':
        return cls(
            "asset_collection",
            _from_json_data(List[ObjectType], data.get("applies_to")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(bool, data.get("wildcard")),
        )

    def to_json_data(self) -> Any:
        data = { "value_type": "asset_collection" }
        data["applies_to"] = _to_json_data(self.applies_to)
        data["description"] = _to_json_data(self.description)
        data["wildcard"] = _to_json_data(self.wildcard)
        return data

@dataclass
class TagRuleAtlas(TagRule):
    applies_to: 'List[ObjectType]'
    description: 'MarkdownString'
    wildcard: 'bool'
    """
    If `true`, this field accepts an array of wildcard IDs. If `false`, this
    field accepts a single non-wildcard ID.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TagRuleAtlas':
        return cls(
            "atlas",
            _from_json_data(List[ObjectType], data.get("applies_to")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(bool, data.get("wildcard")),
        )

    def to_json_data(self) -> Any:
        data = { "value_type": "atlas" }
        data["applies_to"] = _to_json_data(self.applies_to)
        data["description"] = _to_json_data(self.description)
        data["wildcard"] = _to_json_data(self.wildcard)
        return data

@dataclass
class TagRuleAtlasEntry(TagRule):
    applies_to: 'List[ObjectType]'
    description: 'MarkdownString'
    wildcard: 'bool'
    """
    If `true`, this field accepts an array of wildcard IDs. If `false`, this
    field accepts a single non-wildcard ID.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TagRuleAtlasEntry':
        return cls(
            "atlas_entry",
            _from_json_data(List[ObjectType], data.get("applies_to")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(bool, data.get("wildcard")),
        )

    def to_json_data(self) -> Any:
        data = { "value_type": "atlas_entry" }
        data["applies_to"] = _to_json_data(self.applies_to)
        data["description"] = _to_json_data(self.description)
        data["wildcard"] = _to_json_data(self.wildcard)
        return data

@dataclass
class TagRuleBoolean(TagRule):
    applies_to: 'List[ObjectType]'
    array: 'bool'
    description: 'MarkdownString'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TagRuleBoolean':
        return cls(
            "boolean",
            _from_json_data(List[ObjectType], data.get("applies_to")),
            _from_json_data(bool, data.get("array")),
            _from_json_data(MarkdownString, data.get("description")),
        )

    def to_json_data(self) -> Any:
        data = { "value_type": "boolean" }
        data["applies_to"] = _to_json_data(self.applies_to)
        data["array"] = _to_json_data(self.array)
        data["description"] = _to_json_data(self.description)
        return data

@dataclass
class TagRuleDelveSite(TagRule):
    applies_to: 'List[ObjectType]'
    description: 'MarkdownString'
    wildcard: 'bool'
    """
    If `true`, this field accepts an array of wildcard IDs. If `false`, this
    field accepts a single non-wildcard ID.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TagRuleDelveSite':
        return cls(
            "delve_site",
            _from_json_data(List[ObjectType], data.get("applies_to")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(bool, data.get("wildcard")),
        )

    def to_json_data(self) -> Any:
        data = { "value_type": "delve_site" }
        data["applies_to"] = _to_json_data(self.applies_to)
        data["description"] = _to_json_data(self.description)
        data["wildcard"] = _to_json_data(self.wildcard)
        return data

@dataclass
class TagRuleDelveSiteDomain(TagRule):
    applies_to: 'List[ObjectType]'
    description: 'MarkdownString'
    wildcard: 'bool'
    """
    If `true`, this field accepts an array of wildcard IDs. If `false`, this
    field accepts a single non-wildcard ID.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TagRuleDelveSiteDomain':
        return cls(
            "delve_site_domain",
            _from_json_data(List[ObjectType], data.get("applies_to")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(bool, data.get("wildcard")),
        )

    def to_json_data(self) -> Any:
        data = { "value_type": "delve_site_domain" }
        data["applies_to"] = _to_json_data(self.applies_to)
        data["description"] = _to_json_data(self.description)
        data["wildcard"] = _to_json_data(self.wildcard)
        return data

@dataclass
class TagRuleDelveSiteTheme(TagRule):
    applies_to: 'List[ObjectType]'
    description: 'MarkdownString'
    wildcard: 'bool'
    """
    If `true`, this field accepts an array of wildcard IDs. If `false`, this
    field accepts a single non-wildcard ID.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TagRuleDelveSiteTheme':
        return cls(
            "delve_site_theme",
            _from_json_data(List[ObjectType], data.get("applies_to")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(bool, data.get("wildcard")),
        )

    def to_json_data(self) -> Any:
        data = { "value_type": "delve_site_theme" }
        data["applies_to"] = _to_json_data(self.applies_to)
        data["description"] = _to_json_data(self.description)
        data["wildcard"] = _to_json_data(self.wildcard)
        return data

@dataclass
class TagRuleEnum(TagRule):
    applies_to: 'List[ObjectType]'
    array: 'bool'
    description: 'MarkdownString'
    enum: 'List[DictKey]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TagRuleEnum':
        return cls(
            "enum",
            _from_json_data(List[ObjectType], data.get("applies_to")),
            _from_json_data(bool, data.get("array")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(List[DictKey], data.get("enum")),
        )

    def to_json_data(self) -> Any:
        data = { "value_type": "enum" }
        data["applies_to"] = _to_json_data(self.applies_to)
        data["array"] = _to_json_data(self.array)
        data["description"] = _to_json_data(self.description)
        data["enum"] = _to_json_data(self.enum)
        return data

@dataclass
class TagRuleInteger(TagRule):
    applies_to: 'List[ObjectType]'
    array: 'bool'
    description: 'MarkdownString'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TagRuleInteger':
        return cls(
            "integer",
            _from_json_data(List[ObjectType], data.get("applies_to")),
            _from_json_data(bool, data.get("array")),
            _from_json_data(MarkdownString, data.get("description")),
        )

    def to_json_data(self) -> Any:
        data = { "value_type": "integer" }
        data["applies_to"] = _to_json_data(self.applies_to)
        data["array"] = _to_json_data(self.array)
        data["description"] = _to_json_data(self.description)
        return data

@dataclass
class TagRuleMove(TagRule):
    applies_to: 'List[ObjectType]'
    description: 'MarkdownString'
    wildcard: 'bool'
    """
    If `true`, this field accepts an array of wildcard IDs. If `false`, this
    field accepts a single non-wildcard ID.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TagRuleMove':
        return cls(
            "move",
            _from_json_data(List[ObjectType], data.get("applies_to")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(bool, data.get("wildcard")),
        )

    def to_json_data(self) -> Any:
        data = { "value_type": "move" }
        data["applies_to"] = _to_json_data(self.applies_to)
        data["description"] = _to_json_data(self.description)
        data["wildcard"] = _to_json_data(self.wildcard)
        return data

@dataclass
class TagRuleMoveCategory(TagRule):
    applies_to: 'List[ObjectType]'
    description: 'MarkdownString'
    wildcard: 'bool'
    """
    If `true`, this field accepts an array of wildcard IDs. If `false`, this
    field accepts a single non-wildcard ID.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TagRuleMoveCategory':
        return cls(
            "move_category",
            _from_json_data(List[ObjectType], data.get("applies_to")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(bool, data.get("wildcard")),
        )

    def to_json_data(self) -> Any:
        data = { "value_type": "move_category" }
        data["applies_to"] = _to_json_data(self.applies_to)
        data["description"] = _to_json_data(self.description)
        data["wildcard"] = _to_json_data(self.wildcard)
        return data

@dataclass
class TagRuleNpc(TagRule):
    applies_to: 'List[ObjectType]'
    description: 'MarkdownString'
    wildcard: 'bool'
    """
    If `true`, this field accepts an array of wildcard IDs. If `false`, this
    field accepts a single non-wildcard ID.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TagRuleNpc':
        return cls(
            "npc",
            _from_json_data(List[ObjectType], data.get("applies_to")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(bool, data.get("wildcard")),
        )

    def to_json_data(self) -> Any:
        data = { "value_type": "npc" }
        data["applies_to"] = _to_json_data(self.applies_to)
        data["description"] = _to_json_data(self.description)
        data["wildcard"] = _to_json_data(self.wildcard)
        return data

@dataclass
class TagRuleNpcCollection(TagRule):
    applies_to: 'List[ObjectType]'
    description: 'MarkdownString'
    wildcard: 'bool'
    """
    If `true`, this field accepts an array of wildcard IDs. If `false`, this
    field accepts a single non-wildcard ID.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TagRuleNpcCollection':
        return cls(
            "npc_collection",
            _from_json_data(List[ObjectType], data.get("applies_to")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(bool, data.get("wildcard")),
        )

    def to_json_data(self) -> Any:
        data = { "value_type": "npc_collection" }
        data["applies_to"] = _to_json_data(self.applies_to)
        data["description"] = _to_json_data(self.description)
        data["wildcard"] = _to_json_data(self.wildcard)
        return data

@dataclass
class TagRuleOracleCollection(TagRule):
    applies_to: 'List[ObjectType]'
    description: 'MarkdownString'
    wildcard: 'bool'
    """
    If `true`, this field accepts an array of wildcard IDs. If `false`, this
    field accepts a single non-wildcard ID.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TagRuleOracleCollection':
        return cls(
            "oracle_collection",
            _from_json_data(List[ObjectType], data.get("applies_to")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(bool, data.get("wildcard")),
        )

    def to_json_data(self) -> Any:
        data = { "value_type": "oracle_collection" }
        data["applies_to"] = _to_json_data(self.applies_to)
        data["description"] = _to_json_data(self.description)
        data["wildcard"] = _to_json_data(self.wildcard)
        return data

@dataclass
class TagRuleOracleRollable(TagRule):
    applies_to: 'List[ObjectType]'
    description: 'MarkdownString'
    wildcard: 'bool'
    """
    If `true`, this field accepts an array of wildcard IDs. If `false`, this
    field accepts a single non-wildcard ID.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TagRuleOracleRollable':
        return cls(
            "oracle_rollable",
            _from_json_data(List[ObjectType], data.get("applies_to")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(bool, data.get("wildcard")),
        )

    def to_json_data(self) -> Any:
        data = { "value_type": "oracle_rollable" }
        data["applies_to"] = _to_json_data(self.applies_to)
        data["description"] = _to_json_data(self.description)
        data["wildcard"] = _to_json_data(self.wildcard)
        return data

@dataclass
class TagRuleRarity(TagRule):
    applies_to: 'List[ObjectType]'
    description: 'MarkdownString'
    wildcard: 'bool'
    """
    If `true`, this field accepts an array of wildcard IDs. If `false`, this
    field accepts a single non-wildcard ID.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TagRuleRarity':
        return cls(
            "rarity",
            _from_json_data(List[ObjectType], data.get("applies_to")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(bool, data.get("wildcard")),
        )

    def to_json_data(self) -> Any:
        data = { "value_type": "rarity" }
        data["applies_to"] = _to_json_data(self.applies_to)
        data["description"] = _to_json_data(self.description)
        data["wildcard"] = _to_json_data(self.wildcard)
        return data

@dataclass
class TagRuleTruth(TagRule):
    applies_to: 'List[ObjectType]'
    description: 'MarkdownString'
    wildcard: 'bool'
    """
    If `true`, this field accepts an array of wildcard IDs. If `false`, this
    field accepts a single non-wildcard ID.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TagRuleTruth':
        return cls(
            "truth",
            _from_json_data(List[ObjectType], data.get("applies_to")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(bool, data.get("wildcard")),
        )

    def to_json_data(self) -> Any:
        data = { "value_type": "truth" }
        data["applies_to"] = _to_json_data(self.applies_to)
        data["description"] = _to_json_data(self.description)
        data["wildcard"] = _to_json_data(self.wildcard)
        return data

@dataclass
class TemplateString:
    """
    A rich text string in Markdown with replaced values from oracle roll
    results.
    
    The custom syntax `{{some_row_key:some_oracle_table_id}}` should be replaced
    by the `some_row_key` string of a rolled oracle table. This is usually the
    `result` key, for example `{{result:starforged/oracles/core/action}}`
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TemplateString':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class ThemeDangerRowID:
    """
    A unique ID for a ThemeDangerRow.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ThemeDangerRowID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class ThemeFeatureRowID:
    """
    A unique ID for a ThemeFeatureRow.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ThemeFeatureRowID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class TriggerActionRoll:
    """
    Describes trigger conditions for a move that makes an action roll.
    """

    conditions: 'List[TriggerActionRollCondition]'
    """
    Specific conditions that qualify for this trigger.
    """

    text: 'MarkdownString'
    """
    A markdown string containing the primary trigger text for this move.
    
    Secondary trigger text (for specific stats or uses of an asset ability) may
    be described in individual trigger conditions.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerActionRoll':
        return cls(
            _from_json_data(List[TriggerActionRollCondition], data.get("conditions")),
            _from_json_data(MarkdownString, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerActionRollCondition:
    method: 'ActionRollMethod'
    roll_options: 'List[RollableValue]'
    """
    The options available when rolling with this trigger condition.
    """

    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerActionRollCondition':
        return cls(
            _from_json_data(ActionRollMethod, data.get("method")),
            _from_json_data(List[RollableValue], data.get("roll_options")),
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        data["roll_options"] = _to_json_data(self.roll_options)
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerActionRollConditionEnhancement:
    method: 'ActionRollMethod'
    roll_options: 'List[RollableValue]'
    """
    The options available when rolling with this trigger condition.
    """

    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerActionRollConditionEnhancement':
        return cls(
            _from_json_data(ActionRollMethod, data.get("method")),
            _from_json_data(List[RollableValue], data.get("roll_options")),
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        data["roll_options"] = _to_json_data(self.roll_options)
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerActionRollEnhancement:
    """
    Describes changes/additions made to the enhanced move's trigger conditions.
    """

    conditions: 'List[TriggerActionRollConditionEnhancement]'
    """
    Trigger conditions added to the enhanced move.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerActionRollEnhancement':
        return cls(
            _from_json_data(List[TriggerActionRollConditionEnhancement], data.get("conditions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        return data

@dataclass
class TriggerBy:
    """
    Information on who can activate this trigger condition. Usually this is just
    the player, but some asset abilities can trigger from an ally's move.
    """

    ally: 'bool'
    """
    Can this trigger be activated by one of the player's allies?
    """

    player: 'bool'
    """
    Can this trigger be activated by the player who owns this?
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerBy':
        return cls(
            _from_json_data(bool, data.get("ally")),
            _from_json_data(bool, data.get("player")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["ally"] = _to_json_data(self.ally)
        data["player"] = _to_json_data(self.player)
        return data

@dataclass
class TriggerNoRoll:
    """
    Describes trigger conditions for a move that makes no rolls.
    """

    conditions: 'List[TriggerNoRollCondition]'
    text: 'MarkdownString'
    """
    A markdown string containing the primary trigger text for this move.
    
    Secondary trigger text (for specific stats or uses of an asset ability) may
    be described in individual trigger conditions.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerNoRoll':
        return cls(
            _from_json_data(List[TriggerNoRollCondition], data.get("conditions")),
            _from_json_data(MarkdownString, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerNoRollCondition:
    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerNoRollCondition':
        return cls(
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerNoRollEnhancement:
    """
    Describes changes/additions made to the enhanced move's trigger conditions.
    """

    conditions: 'List[TriggerNoRollCondition]'
    """
    Trigger conditions added to the enhanced move.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerNoRollEnhancement':
        return cls(
            _from_json_data(List[TriggerNoRollCondition], data.get("conditions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        return data

@dataclass
class TriggerProgressRoll:
    conditions: 'List[TriggerProgressRollCondition]'
    """
    Specific conditions that qualify for this trigger.
    """

    text: 'MarkdownString'
    """
    A markdown string containing the primary trigger text for this move.
    
    Secondary trigger text (for specific stats or uses of an asset ability) may
    be described in individual trigger conditions.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerProgressRoll':
        return cls(
            _from_json_data(List[TriggerProgressRollCondition], data.get("conditions")),
            _from_json_data(MarkdownString, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerProgressRollCondition:
    method: 'ProgressRollMethod'
    roll_options: 'List[ProgressRollOption]'
    """
    The options available when rolling with this trigger condition.
    """

    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerProgressRollCondition':
        return cls(
            _from_json_data(ProgressRollMethod, data.get("method")),
            _from_json_data(List[ProgressRollOption], data.get("roll_options")),
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        data["roll_options"] = _to_json_data(self.roll_options)
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerProgressRollConditionEnhancement:
    method: 'ProgressRollMethod'
    roll_options: 'List[ProgressRollOption]'
    """
    The options available when rolling with this trigger condition.
    """

    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerProgressRollConditionEnhancement':
        return cls(
            _from_json_data(ProgressRollMethod, data.get("method")),
            _from_json_data(List[ProgressRollOption], data.get("roll_options")),
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        data["roll_options"] = _to_json_data(self.roll_options)
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerProgressRollEnhancement:
    """
    Describes changes/additions made to the enhanced move's trigger conditions.
    """

    conditions: 'List[TriggerProgressRollConditionEnhancement]'
    """
    Trigger conditions added to the enhanced move.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerProgressRollEnhancement':
        return cls(
            _from_json_data(List[TriggerProgressRollConditionEnhancement], data.get("conditions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        return data

@dataclass
class TriggerSpecialTrack:
    conditions: 'List[TriggerSpecialTrackCondition]'
    """
    Specific conditions that qualify for this trigger.
    """

    text: 'MarkdownString'
    """
    A markdown string containing the primary trigger text for this move.
    
    Secondary trigger text (for specific stats or uses of an asset ability) may
    be described in individual trigger conditions.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerSpecialTrack':
        return cls(
            _from_json_data(List[TriggerSpecialTrackCondition], data.get("conditions")),
            _from_json_data(MarkdownString, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerSpecialTrackCondition:
    method: 'SpecialTrackRollMethod'
    roll_options: 'List[TriggerSpecialTrackConditionOption]'
    """
    The options available when rolling with this trigger condition.
    """

    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerSpecialTrackCondition':
        return cls(
            _from_json_data(SpecialTrackRollMethod, data.get("method")),
            _from_json_data(List[TriggerSpecialTrackConditionOption], data.get("roll_options")),
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        data["roll_options"] = _to_json_data(self.roll_options)
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerSpecialTrackConditionEnhancement:
    """
    A progress move that rolls on one or more special tracks, like Bonds
    (classic Ironsworn), Failure (Delve), or Legacy (Starforged).
    """

    method: 'SpecialTrackRollMethod'
    roll_options: 'List[TriggerSpecialTrackConditionOption]'
    """
    The options available when rolling with this trigger condition.
    """

    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerSpecialTrackConditionEnhancement':
        return cls(
            _from_json_data(SpecialTrackRollMethod, data.get("method")),
            _from_json_data(List[TriggerSpecialTrackConditionOption], data.get("roll_options")),
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        data["roll_options"] = _to_json_data(self.roll_options)
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerSpecialTrackConditionOption:
    using: 'SpecialTrackType'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerSpecialTrackConditionOption':
        return cls(
            _from_json_data(SpecialTrackType, data.get("using")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["using"] = _to_json_data(self.using)
        return data

@dataclass
class TriggerSpecialTrackEnhancement:
    """
    Describes changes/additions made to the enhanced move's trigger conditions.
    """

    conditions: 'List[TriggerSpecialTrackConditionEnhancement]'
    """
    Trigger conditions added to the enhanced move.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerSpecialTrackEnhancement':
        return cls(
            _from_json_data(List[TriggerSpecialTrackConditionEnhancement], data.get("conditions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        return data

@dataclass
class Truth:
    """
    A setting truth category.
    """

    id: 'TruthID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    options: 'List[TruthOption]'
    source: 'SourceInfo'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    icon: 'Optional[SvgImageURL]'
    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    tags: 'Optional[Dict[str, Dict[str, Tag]]]'
    your_character: 'Optional[MarkdownString]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Truth':
        return cls(
            _from_json_data(TruthID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[TruthOption], data.get("options")),
            _from_json_data(SourceInfo, data.get("source")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Dict[str, Dict[str, Tag]]], data.get("tags")),
            _from_json_data(Optional[MarkdownString], data.get("your_character")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["options"] = _to_json_data(self.options)
        data["source"] = _to_json_data(self.source)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.tags is not None:
             data["tags"] = _to_json_data(self.tags)
        if self.your_character is not None:
             data["your_character"] = _to_json_data(self.your_character)
        return data

@dataclass
class TruthID:
    """
    A unique ID for a Truth.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TruthID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class TruthOption:
    description: 'MarkdownString'
    id: 'TruthOptionID'
    """
    The unique Datasworn ID for this item.
    """

    quest_starter: 'MarkdownString'
    max: 'Optional[int]'
    min: 'Optional[int]'
    summary: 'Optional[MarkdownString]'
    table: 'Optional[List[TruthOptionTableRow]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TruthOption':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(TruthOptionID, data.get("id")),
            _from_json_data(MarkdownString, data.get("quest_starter")),
            _from_json_data(Optional[int], data.get("max")),
            _from_json_data(Optional[int], data.get("min")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[List[TruthOptionTableRow]], data.get("table")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["id"] = _to_json_data(self.id)
        data["quest_starter"] = _to_json_data(self.quest_starter)
        if self.max is not None:
             data["max"] = _to_json_data(self.max)
        if self.min is not None:
             data["min"] = _to_json_data(self.min)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.table is not None:
             data["table"] = _to_json_data(self.table)
        return data

@dataclass
class TruthOptionID:
    """
    A unique ID for a TruthOption.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TruthOptionID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class TruthOptionTableRow:
    """
    Represents a row in an oracle table.
    """

    max: 'int'
    """
    High end of the dice range for this table row.
    """

    min: 'int'
    """
    Low end of the dice range for this table row.
    """

    result: 'MarkdownString'
    """
    The primary text content of this row.
    """

    embed_table: 'Optional[OracleRollableID]'
    """
    Hints that the identified table should be rendered inside this table row.
    """

    i18n: 'Optional[I18nHints]'
    icon: 'Optional[SvgImageURL]'
    oracle_rolls: 'Optional[List[OracleRoll]]'
    """
    Further oracle rolls prompted by this table row.
    """

    suggestions: 'Optional[Suggestions]'
    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TruthOptionTableRow':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(MarkdownString, data.get("result")),
            _from_json_data(Optional[OracleRollableID], data.get("embed_table")),
            _from_json_data(Optional[I18nHints], data.get("i18n")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleRoll]], data.get("oracle_rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["result"] = _to_json_data(self.result)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.i18n is not None:
             data["i18n"] = _to_json_data(self.i18n)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.oracle_rolls is not None:
             data["oracle_rolls"] = _to_json_data(self.oracle_rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class WebURL:
    """
    An absolute URL pointing to a website.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'WebURL':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class WebpImageURL:
    """
    A relative (local) URL pointing to a raster image in the WEBP format.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'WebpImageURL':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

def _from_json_data(cls: Any, data: Any) -> Any:
    if data is None or cls in [bool, int, float, str, object] or cls is Any:
        return data
    if cls is datetime:
        return _parse_rfc3339(data)
    if get_origin(cls) is Union:
        return _from_json_data(get_args(cls)[0], data)
    if get_origin(cls) is list:
        return [_from_json_data(get_args(cls)[0], d) for d in data]
    if get_origin(cls) is dict:
        return { k: _from_json_data(get_args(cls)[1], v) for k, v in data.items() }
    return cls.from_json_data(data)

def _to_json_data(data: Any) -> Any:
    if data is None or type(data) in [bool, int, float, str, object]:
        return data
    if type(data) is datetime:
        return data.isoformat()
    if type(data) is list:
        return [_to_json_data(d) for d in data]
    if type(data) is dict:
        return { k: _to_json_data(v) for k, v in data.items() }
    return data.to_json_data()

def _parse_rfc3339(s: str) -> datetime:
    datetime_re = '^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(\.\d+)?([zZ]|((\+|-)(\d{2}):(\d{2})))$'
    match = re.match(datetime_re, s)
    if not match:
        raise ValueError('Invalid RFC3339 date/time', s)

    (year, month, day, hour, minute, second, frac_seconds, offset,
     *tz) = match.groups()

    frac_seconds_parsed = None
    if frac_seconds:
        frac_seconds_parsed = int(float(frac_seconds) * 1_000_000)
    else:
        frac_seconds_parsed = 0

    tzinfo = None
    if offset == 'Z':
        tzinfo = timezone.utc
    else:
        hours = int(tz[2])
        minutes = int(tz[3])
        sign = 1 if tz[1] == '+' else -1

        if minutes not in range(60):
            raise ValueError('minute offset must be in 0..59')

        tzinfo = timezone(timedelta(minutes=sign * (60 * hours + minutes)))

    second_parsed = int(second)
    if second_parsed == 60:
        second_parsed = 59

    return datetime(int(year), int(month), int(day), int(hour), int(minute),
                    second_parsed, frac_seconds_parsed, tzinfo)            
